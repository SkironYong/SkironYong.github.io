<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式——单例模式</title>
      <link href="/posts/6cc9630a.html"/>
      <url>/posts/6cc9630a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton）是设计模式中最简单的一种，这种设计模式属于设计模式中的<font color="red">创建型模式</font>，它提供了一种创建对象的最佳方法</p><p>单例模式必须确保<strong>单例对象的类必须只有一个实例存在</strong>。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时保证只有一个对象被创建。这个类提供一个公开的方法来访问其唯一的对象，而不需要实例化该类的对象。</p><p>在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序常被设计成单例。比如，每台计算机可以有若干个通信端口，系统应当以<font color="blue">单例</font>管理这些端口，以避免一个通信端口同时被两个请求同时调用。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200604104019.jpg" alt></p><p>上图UML有几个知识点：</p><ul><li>一条带空心菱形箭头的直线表示的是 <strong>聚合关系</strong></li><li>一条带箭头的直线表示的是 <strong>关联关系</strong>，是一种”强关联”的关系</li><li>+表示公有方法，-表示私有方法，#表示protected</li></ul><h2 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h2><ul><li><font color="red">私有构造方法</font></li><li><font color="red">指向自己实例的私有静态引用</font></li><li><font color="red">以自己实例为返回值的静态公有方法</font></li></ul><h2 id="单线程环境的两种实现"><a href="#单线程环境的两种实现" class="headerlink" title="单线程环境的两种实现"></a>单线程环境的两种实现</h2><p>我们首先介绍一下两个概念：<strong>立即加载</strong>和<strong>延迟加载</strong> 。</p><ul><li><strong>立即加载</strong>：在类加载初始化的时候主动创建实例</li><li><strong>延迟加载</strong>：等真正使用时候才去创建实例，不用主动创建实例</li></ul><p>在单线程环境，单例模式根据实例化对象的时机不同，有两种方式：<strong>饿汉式（立即加载）</strong>，<strong>懒汉式（延迟加载）</strong></p><p>饿汉式在单例类被加载的时候，就实例化一个对象并交给自己的引用；懒汉式只有在真正使用时才会实例化一个对象并交给自己的引用。</p><h1 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200604113541.png" alt></p><p>类加载在整个类生命周期中<strong>只会被加载一次</strong>，所以当多线程访问单例对象之前就已经创建好了，所以线程每次都拿的是唯一的对象，所以是<font color="red">天然线程安全</font>的。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200604113555.png" alt></p><div class="note success">            <p>优点</p>          </div><p>写法简单，在类加载的时候就完成实例化，避免线程同步问题</p><div class="note danger">            <p>缺点</p>          </div><p>如果程序没有用过这个实例，就会造成内存的浪费</p><p>没有达到延迟加载的效果</p><p><strong>多线程检测：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;threads.length;i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> TestThread();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;threads.length;i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多线程下，打印获取到的hashCode，看获取到的单例是否相同</span></span><br><span class="line">        <span class="keyword">int</span> hash = Singleton2.getSingleton2().hashCode();</span><br><span class="line">        System.out.println(hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200604113547.png" alt></p><p>懒汉式是延迟加载，是<font color="red">非线程安全</font>的，<font color="green">会有多个线程同时进入if（singleton2==null）的情况发生，会创建出多个实例，违背单例模式的设计思想</font></p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200604113551.png" alt></p><h2 id="懒汉式（synchronized修饰静态方法）"><a href="#懒汉式（synchronized修饰静态方法）" class="headerlink" title="懒汉式（synchronized修饰静态方法）"></a>懒汉式（synchronized修饰静态方法）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.指向自己实例的私有静态引用，不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 singleton3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用synchronized修饰静态方法，临界资源同步互斥访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title">getSingleton3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(singleton3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton3 = <span class="keyword">new</span> Singleton3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>使用synchronized修饰静态方法，就相当于<strong>加对象锁</strong>，保证了同步互斥访问，但是这种方法同步的范围太大，<strong>锁的粒度有点粗</strong></p>          </div><h2 id="懒汉式（synchronized修饰代码块）"><a href="#懒汉式（synchronized修饰代码块）" class="headerlink" title="懒汉式（synchronized修饰代码块）"></a>懒汉式（synchronized修饰代码块）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.指向自己实例的私有静态引用，不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 singleton4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用synchronized同步代码块，临界资源同步互斥访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton4 <span class="title">getSingleton4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(singleton4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                singleton4 = <span class="keyword">new</span> Singleton4();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>这种方法跟上面的类似，不过是加类锁，保证了线程同步</p>          </div><h2 id="使用内部类实现延迟加载"><a href="#使用内部类实现延迟加载" class="headerlink" title="使用内部类实现延迟加载"></a>使用内部类实现延迟加载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  内部类</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.私有内部类，按需加载, 实现延迟加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 singleton3 = <span class="keyword">new</span> Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.以内部类实例为返回值的静态公有方法，静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getSingleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.singleton3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>这是一种高效的实现线程安全的懒汉式单例，为什么是线程安全的？原理和饿汉式类似，内部类都是在类加载时就完成内部类的实例化</p>          </div><h2 id="懒汉式（双重检查）"><a href="#懒汉式（双重检查）" class="headerlink" title="懒汉式（双重检查）"></a>懒汉式（双重检查）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式--双重检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.指向自己实例的私有静态引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 singleton4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供一个静态的公有方法</span></span><br><span class="line">    <span class="comment">// 加入双重检查代码，解决线程安全问题，同时解决延迟加载问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getSingleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//只需在第一次创建实例时才同步</span></span><br><span class="line">                <span class="keyword">if</span>(singleton4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton4 = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton4;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>这种双重检查的目的就是为了避开过多的同步：<font color="red">这里的同步只需在第一次创建实例时同步，一旦创建成功，后面的实例就不需要同步获取锁了</font></p>          </div><p>这里我们要强调一点:</p><p><strong>必须使用volatile关键字修饰单例引用</strong></p><hr><p><font color="green">如果没有用volatile关键字修饰singleton4，会发生什么呢？</font></p><p>在java虚拟机中，<code>new Singleton4()</code>这个操作分3个步骤执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory &#x3D; allocate()   &#x2F;&#x2F;1分配对象的内存空间</span><br><span class="line">ctorInstance(memory)&#x2F;&#x2F;2初始化对象</span><br><span class="line">singleton4  &#x3D; memory&#x2F;&#x2F;3用singleton4指针指向刚才分配的内存空间</span><br></pre></td></tr></table></figure><p>但这三个步骤在指令的实际执行过程中并不一定按照上面的顺序（<font color="red">指令重排序</font>）</p><p>这就会导致一个严重的问题：<font color="blue">在Singleton构造函数执行之前，变量singleton4可能提前变成非null的，就是赋值语句在对象实例化之前调用，这时，别的线程得到的对象就是一个不完整（未初始化）的对象，导致系统崩溃</font>。</p><p>而volatile的一个作用就是<strong>防止指令重排序</strong></p><h2 id="单例模式与ThreadLocal"><a href="#单例模式与ThreadLocal" class="headerlink" title="单例模式与ThreadLocal"></a>单例模式与ThreadLocal</h2><p>借助ThreadLocal，我们可以实现双重检查的变体，即：</p><p>将临界资源线程局部化，这里就是将双重检查的第一层检查条件<code>if(singleton4==null)</code>转换成<font color="red">线程局部范围内操作</font>，用<code>ThreadLocal标识线程</code>，看是否已经访问过，如果已经访问过了就不用进行线程同步，提高了效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ThreadLocal 线程局部变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Singleton4&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Singleton4&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 singleton4 = <span class="keyword">null</span>; <span class="comment">//指向自身实例的静态私有引用</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//私有构造方法</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getSingleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadLocal.get() == <span class="keyword">null</span>) &#123;        <span class="comment">//用threadlocal检查线程是否标记 </span></span><br><span class="line">           <span class="comment">//第一次检查：该线程是否第一次访问</span></span><br><span class="line">            createSingleton4();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton4;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createSingleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton4 == <span class="keyword">null</span>) &#123;          <span class="comment">// 第二次检查：该单例是否被创建</span></span><br><span class="line">                singleton4 = <span class="keyword">new</span> Singleton4();   <span class="comment">// 只执行一次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        threadLocal.set(singleton4);      <span class="comment">// 将单例放入当前线程的局部变量中 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger">            <p>借助ThreadLocal线程池也可以实现线程安全的懒汉式单例模式，只不过，实现效率不如双重检查锁定</p>          </div><h1 id="单例模式在JDK源码分析"><a href="#单例模式在JDK源码分析" class="headerlink" title="单例模式在JDK源码分析"></a>单例模式在JDK源码分析</h1><p>单例模式(饿汉式)典型的就是<code>java.lang.RunTime</code></p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200605000136.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例懒汉式的实现方式有很多，总结来讲，要想实现效率高的线程安全的单例模式，就要满足：</p><ul><li>尽量减少同步代码块的作用域</li><li>尽量使用细粒度的锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二次面经（数据库考察）</title>
      <link href="/posts/53c56b2b.html"/>
      <url>/posts/53c56b2b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">            <p>2020.5.22上午投递的百度后端开发母婴业务，下午就收到了hr约面试的电话📞，说了主要方向可能是php方向，接不接受转语言（我说当然可以），然后约到了下周二的上午电话面试。</p>          </div><p>5.26百度一面，刚开始面试的时候因为信号不好导致听不清人家在说啥（把varchar和char听成了乘和差？？？），面试官人也很nice多次重复给我讲清了题目（仿佛在量子通信hhh），总时间大概50多分钟，比第一次情况有小进步。话不多说，回顾一下：</p><ol><li>介绍自己balabala,项目说了一下是自己学习的项目。数据库MySQL里char和varchar的区别，意思。</li></ol><blockquote><p>char是定长字符，0-255字节，若插入超过设定长度，会被截取并告知</p><p>varchar是变长字符，最高支持65535个字节。</p></blockquote><ol start="2"><li><p>数据库查询优化有哪些？</p></li><li><p>主从数据库怎么保证数据一致性？如何同步</p></li><li><p>说到了Redis能优化查询，Redis几种数据结构？举个源码的例子</p></li><li><p>有序集合的内部编码</p></li><li><p>Redis宕机怎么办，Redis持久化</p></li><li><p>Redis是单线程还是多线程，怎么做到高并发？</p></li><li><p>MySql其他优化方案？数据库分区讲一下</p></li><li><p>ACID原则，所有数据库引擎都支持吗，怎么保证</p></li><li><p>InnoDB的并发控制MVCC了解吗（完了，没了解）</p></li><li><p>下面是一个实例题：</p><p>问题1：有张表tabel,两个字段a,b，开启左、右两个窗口，右窗口a=1,b=1.左窗口更新b=2,（未提交事务） ，右窗口读取b，问b的值是多少？</p><p>问题2：更新b=3，（提交事务），问读取这时的b为多少？</p></li><li><p>算法题：用堆栈实现一个队列，如何判断链表有环？</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一张图搞懂MySQL优化</title>
      <link href="/posts/5b6662c7.html"/>
      <url>/posts/5b6662c7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">            <p>开局一张图</p>          </div><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200528232852.jpg" style="zoom:50%;"><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h2><ul><li>系统吞吐量瓶颈往往出现在数据库访问速度中</li><li>随着应用程序运行，数据库的数据越来越多，处理时间变慢</li><li>数据存在磁盘上，读写速度不如内存</li></ul><h2 id="怎样优化"><a href="#怎样优化" class="headerlink" title="怎样优化"></a>怎样优化</h2><p>本文从以下几个方面来对数据库进行优化：</p><ol><li>数据库的设计：数据库表、字段设计、存储引擎选择</li><li>数据库自身的优化：索引</li><li>横向扩展、数据库主从复制、读写分离、负载均衡和高可用</li><li>SQL语句优化</li></ol><h1 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2. 数据库设计"></a>2. 数据库设计</h1><h2 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h2><p>字段设计有以下几种设计原则：</p><h3 id="原则1-尽量使用整数来表示字符串"><a href="#原则1-尽量使用整数来表示字符串" class="headerlink" title="原则1. 尽量使用整数来表示字符串"></a>原则1. 尽量使用整数来表示字符串</h3><p>因为字符集和校验规则，<strong>处理字符比整型复杂</strong>，比如：<code>我们使用数据库内置的datetime存储时间而不是字符类型，使用整型存储IP地址，而不是将IP字符存储到数据库中</code></p><p>使用整型数表示字符串有两大优势：</p><ul><li>整数所占存储空间一般小于字符串</li><li>整数的运算速度快</li></ul><h3 id="原则2-定长和非定长数据类型的选择"><a href="#原则2-定长和非定长数据类型的选择" class="headerlink" title="原则2.定长和非定长数据类型的选择"></a>原则2.定长和非定长数据类型的选择</h3><p><strong>使用定点数表示浮点数</strong></p><p>浮点数在计算机中保存和运算容易失真，对于银行金额精度要求高的数据，用<code>定点数decimal</code>存储，定义decimal(P,D)可以创建一个整数位为P位，小数位最多为D位的定点数</p><p><strong>用小单位表示大数额避免出现小数</strong></p><p>元-&gt;分</p><h3 id="原则3-尽可能选择小的数据类型"><a href="#原则3-尽可能选择小的数据类型" class="headerlink" title="原则3.尽可能选择小的数据类型"></a>原则3.尽可能选择小的数据类型</h3><h3 id="原则4-尽可能使用not-null非空字段"><a href="#原则4-尽可能使用not-null非空字段" class="headerlink" title="原则4.尽可能使用not null非空字段"></a>原则4.尽可能使用not null非空字段</h3><p>非null字段的处理比Null字段的处理更高效，而且不需要判断null</p><p>null值在MySQL中，需要额外的存储空间（null字段需要用占位符占位），运算也需要特殊的运算符（通过is null和 is not null来判断）</p><h3 id="原则5-单表字段不宜过多，注释要完整，可以预留字段"><a href="#原则5-单表字段不宜过多，注释要完整，可以预留字段" class="headerlink" title="原则5.单表字段不宜过多，注释要完整，可以预留字段"></a>原则5.单表字段不宜过多，注释要完整，可以预留字段</h3><h3 id="原则6-满足范式"><a href="#原则6-满足范式" class="headerlink" title="原则6.满足范式"></a>原则6.满足范式</h3><p><strong>第一范式1NF:原子性</strong></p><blockquote><p>关系型数据库，默认满足第一范式</p></blockquote><p><strong>第二范式2NF:消除对主键的部分依赖</strong></p><p>举个例子：知道了下一节课是数学课，就能确定任课老师是谁。于是<strong>周几</strong>和<strong>下一节课</strong>和就能构成复合主键，能够确定去哪个教室上课，任课老师是谁等。但我们常常<strong>增加一个id作为主键</strong>，而消除对主键的部分依赖。</p><p><strong>第三范式3NF:消除对主键的传递依赖</strong></p><p>消除传递依赖就是将表拆分，独立建表</p><h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><div class="note info">            <p>MySQL默认选择的是Innodb，现在已经全面超过MyISAM了</p>          </div><table><thead><tr><th align="center"></th><th align="center">MyISAM</th><th align="center">Innodb</th></tr></thead><tbody><tr><td align="center">文件格式</td><td align="center">数据和索引是分别存储的，数据文件.MYD，索引文件.MYI</td><td align="center">数据和索引是集中存储的.ibd文件</td></tr><tr><td align="center">文件能否移动</td><td align="center">可以，一张表对应.frm，MYD,MYI3个文件</td><td align="center">不能，因为关联的还有data下的其他文件</td></tr><tr><td align="center">事务</td><td align="center">:x:</td><td align="center">:ballot_box_with_check:</td></tr><tr><td align="center">外键</td><td align="center">:x:</td><td align="center">:ballot_box_with_check:</td></tr><tr><td align="center">锁支持</td><td align="center">表级锁定</td><td align="center">行级锁定、表级锁定</td></tr><tr><td align="center">记录存储顺序</td><td align="center">按记录插入顺序保存</td><td align="center">按主键大小有序插入</td></tr><tr><td align="center">空间碎片</td><td align="center">产生，定时整理：使用命令optimize table 表名实现</td><td align="center">不产生</td></tr></tbody></table><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h1><p>索引为什么快？</p><p>索引记录的关键字是有序的+索引关键字相对于数据本身是小的</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>普通索引index:对关键字没要求</li></ul><blockquote><p>index ‘xingming’ (‘xing’, ‘ming’)  – 复合索引</p></blockquote><ul><li>唯一索引unique index:要求关键字不能重复，同时增加唯一约束</li></ul><blockquote><p>unique index ‘ui’ (‘stu_id’)  – 唯一索引</p></blockquote><ul><li>主键索引primary key:要求关键字不能重复，也不能为NULL</li></ul><blockquote><p>primary key  (‘stu_id’)  – 主索引</p></blockquote><ul><li>全文索引fulltext key: 关键字的来源不是所有字段的数据，而是从字段中提取的特殊关键字</li></ul><blockquote><p>fulltext index  ‘desc’  (‘stu_desc’)  – 全文索引</p></blockquote><p>可以通过使用<code>explain + SQL</code>语句来执行计划，查询执行后的变化</p><h2 id="索引规则"><a href="#索引规则" class="headerlink" title="索引规则"></a>索引规则</h2><p>如果索引不遵循使用原则，则索引无效</p><ol><li>列独立</li></ol><p>如果需要某个字段上使用索引，则需要在字段参与的表达中，保证字段独立在一侧。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200528202125.png" alt></p><p>如果empno加入运算，比如empno-1索引就会无效。</p><ol start="2"><li>左原则</li></ol><p>Like：匹配模式必须要左边确定不能以通配符开头</p><blockquote><p>explain select * from emp where ename like  ‘%abc’  – 不能使用索引</p><p>explain select * from emp where ename like  ‘_abc’  – 不能使用索引</p></blockquote><ol start="3"><li>OR使用</li></ol><p>必须保证OR两端的条件都存在可以用的索引，则该查询才可以使用索引</p><ol start="4"><li>复合索引</li></ol><p><strong>复合索引仅仅针对左边字段有效果</strong>（复合索引先查最左边字段，当最左边字段相等，才查找最右边字段）</p><ol start="5"><li>状态值</li></ol><p>像性别这样的状态值，一个关键字对应多条数据，会认为使用索引比全表扫描效率还低</p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><ul><li>btree: 搜索多叉树,结点内关键字有序排列，关键字之间有一个指针</li><li>b+tree：由btree升级而来，数据和关键字存储在一块，省去了由关键字到数据的映射然后再找数据存放地 的 时间</li></ul><h2 id="索引选择经验"><a href="#索引选择经验" class="headerlink" title="索引选择经验"></a>索引选择经验</h2><ul><li>不要过度索引，索引越多，占用空间越大，性能反而更慢</li><li>只对where子句中频繁使用的关键字建立索引</li><li>尽可能使用唯一索引，重复值越少，索引效果越强</li><li>索引存在，不满足规则，则索引无效</li></ul><p><strong>使用场景：</strong></p><ul><li>where语句</li><li>order by</li><li>join 对join语句匹配关系(on)涉及的字段来建立索引</li></ul><h1 id="4-查询缓存"><a href="#4-查询缓存" class="headerlink" title="4.查询缓存"></a>4.查询缓存</h1><p>开启缓存能缓存select语句查询的结果，在配置文件中开启</p><p>windows上是<code>my.ini</code>，linux上是<code>my.cnf</code></p><p>在[mysqld]段中配置query_***_type：</p><ul><li>0：不开启</li><li>1：开启，默认缓存所有</li><li>2：开启，默认都不缓存</li></ul><p>客户端通过<code>query_cache_size</code>来设置缓存大小</p><p><strong>缓存失效问题</strong>：存在一个大问题就是，当数据表改动的时候，表的任何缓存都会被删除</p><h1 id="5-分区"><a href="#5-分区" class="headerlink" title="5.分区"></a>5.分区</h1><p>默认情况下一张表对应一组缓存文件，但当数据量较大的时候（通常千万条级别）需要将数据分到多组存储文件，保证单个文件的处理效率</p><p>使用Innodb存储引擎时对应的是.idb和.frm(表结构)文件</p><p>最常见分区方法是按Id分区，比如将Id的哈希值对10取模将数据分散到10个.ibd存储文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table article(</span><br><span class="line">    id int auto_increment PRIMARY KEY,</span><br><span class="line">    title varchar(64),</span><br><span class="line">    content text</span><br><span class="line">)PARTITION by HASH(id) PARTITIONS 10</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200528224627.png" alt></p><h2 id="MySQL的分区算法"><a href="#MySQL的分区算法" class="headerlink" title="MySQL的分区算法"></a>MySQL的分区算法</h2><h3 id="hash（field）"><a href="#hash（field）" class="headerlink" title="hash（field）"></a>hash（field）</h3><h3 id="key（field）"><a href="#key（field）" class="headerlink" title="key（field）"></a>key（field）</h3><p>与hash性质一样，不过Key是处理<strong>字符串</strong>的，多了一步从字符串中计算出一个整数再取模的操作</p><h3 id="range算法"><a href="#range算法" class="headerlink" title="range算法"></a>range算法</h3><p>是一种按条件分区的算法，按照数据大小范围分区</p><p>如下，按文章的发布时间将数据按照2018 8月、9月、10月分区存放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table article_range(</span><br><span class="line">    id int auto_increment,</span><br><span class="line">    title varchar(64),</span><br><span class="line">    content text,</span><br><span class="line">    created_time int,    -- 发布时间到1970-1-1的毫秒数</span><br><span class="line">    PRIMARY KEY (id,created_time)    -- 要求分区依据字段必须是主键的一部分</span><br><span class="line">)charset&#x3D;utf8</span><br><span class="line">PARTITION BY RANGE(created_time)(</span><br><span class="line">    PARTITION p201808 VALUES less than (1535731199),    -- select UNIX_TIMESTAMP(&#39;2018-8-31 23:59:59&#39;)</span><br><span class="line">    PARTITION p201809 VALUES less than (1538323199),    -- 2018-9-30 23:59:59</span><br><span class="line">    PARTITION p201810 VALUES less than (1541001599)    -- 2018-10-31 23:59:59</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="list算法"><a href="#list算法" class="headerlink" title="list算法"></a>list算法</h3><p>是一种条件分区，按照列表值分区（in(值列表)）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table article_list(</span><br><span class="line">    id int auto_increment,</span><br><span class="line">    title varchar(64),</span><br><span class="line">    content text,</span><br><span class="line">    status TINYINT(1),    -- 文章状态：0-草稿，1-完成但未发布，2-已发布</span><br><span class="line">    PRIMARY KEY (id,status)    -- 要求分区依据字段必须是主键的一部分</span><br><span class="line">)charset&#x3D;utf8</span><br><span class="line">PARTITION BY list(status)(</span><br><span class="line">    PARTITION writing values in(0,1),    -- 未发布的放在一个分区   </span><br><span class="line">    PARTITION published values in (2)    -- 已发布的放在一个分区</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="6-水平分割-垂直分割"><a href="#6-水平分割-垂直分割" class="headerlink" title="6.水平分割/垂直分割"></a>6.水平分割/垂直分割</h1><p><strong>水平分割</strong>：通过建立结构相同的几张表分别存储数据</p><p><strong>垂直分割</strong>：将经常一起使用的字段放在一个单独的表中，分割后的表记录之间是一一对应关系</p><h1 id="7-集群"><a href="#7-集群" class="headerlink" title="7.集群"></a>7.集群</h1><div class="note success">            <p>数据库进行横向扩展：从根本上（单机的硬件处理能力有限）提升数据库的性能。所以产生了相关的技术：读写分离（主从复制）、负载均衡</p>          </div><h2 id="集群的环境配置"><a href="#集群的环境配置" class="headerlink" title="集群的环境配置"></a>集群的环境配置</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>读写分离是依赖于主从复制。下面我们来讲讲主从复制的实现原理</p><p><strong>MySQL主从复制原理</strong></p><p>主从复制指的是可以一个M有SQL数据库服务器主节点复制到一个或多个节点。MySQL默认采用<strong>异步复制</strong>的方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><p><strong>主要作用</strong></p><p>在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><p><strong>主要原理</strong></p><p>MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点，如下图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200529142924.png" alt></p><ul><li>异步模式</li></ul><p>采用一主两从的架构模式，master上进行修改，执行，提交，之后master将结果语句修改的调用方，告诉他数据修改成功。之后将数据的修改写入到二进制日志中，会从slave的IO进程存储到slave的relay log中，两个slave服务器分别从SQL进程中读取relay log 事件，并在本地数据库来应用。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200529143420.png" alt></p><ul><li>半同步模式</li></ul><p>采用一主两从的架构，master上进行修改，执行，之后master将结果语句修改的调用方，告诉他数据修改成功。之后将数据的修改写入到二进制日志中，然后通过IO进行同步到slave端并计入到relay log中，但和异步模式不同的是：这时候slave会向master发送消息，只有收到对slave确认消息之后才会继续操作提交，之后主从才会把修改好的数据返回给客户端。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200529143832.png" alt></p><h1 id="8-开启慢查询日志"><a href="#8-开启慢查询日志" class="headerlink" title="8.开启慢查询日志"></a>8.开启慢查询日志</h1><div class="note success">            <p>慢查询日志：用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为优化做参考</p>          </div><ol><li>开启慢查询日志</li></ol><p><strong>配置项：slow_query_log</strong></p><p>可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。</p><ol start="2"><li>设置临界时间</li></ol><p>配置项：long_query_time </p><p>  查看：show VARIABLES like ‘long_query_time’，单位秒 </p><p>  设置：set long_query_time=0.5 </p><p>  实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p><ol start="3"><li>查看日志</li></ol><p>一旦SQL超过了设置的临界时间，就会被记录到xxx-slow.log中</p><h1 id="9-压测工具mysqlslap"><a href="#9-压测工具mysqlslap" class="headerlink" title="9.压测工具mysqlslap"></a>9.压测工具mysqlslap</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习</title>
      <link href="/posts/9a8cdc59.html"/>
      <url>/posts/9a8cdc59.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、OSI模型结构和功能"><a href="#一、OSI模型结构和功能" class="headerlink" title="一、OSI模型结构和功能"></a>一、OSI模型结构和功能</h1><p>OSI有七层体系结构：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。</p><p>中和OSI和TCP/IP的优点，提出五层模型：物理层、数据链路层、网络层、运输层、应用层。</p><h1 id="二、TCP三次握手和四次挥手（重点）"><a href="#二、TCP三次握手和四次挥手（重点）" class="headerlink" title="二、TCP三次握手和四次挥手（重点）"></a>二、TCP三次握手和四次挥手（重点）</h1><h3 id="常用的端口号"><a href="#常用的端口号" class="headerlink" title="常用的端口号"></a>常用的端口号</h3><table><thead><tr><th align="center">应用程序</th><th>FTP</th><th>TFTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>HTTP</th><th>SSH</th><th>MYSQL</th></tr></thead><tbody><tr><td align="center">熟知端口</td><td>21,20</td><td>69</td><td>23</td><td>25</td><td>53</td><td>80</td><td>22</td><td>3306</td></tr><tr><td align="center">传输层协议</td><td>TCP</td><td>UDP</td><td>TCP</td><td>TCP</td><td>UDP</td><td>TCP</td><td>TCP</td><td>TCP</td></tr></tbody></table><h3 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h3><div class="note warning">            <p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>          </div><h3 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h3><ol><li>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</li><li>序号，占4个字节，<font color="red">TCP连接中传送的字节流中的每个字节都按顺序编号</font>font&gt;。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li><li>确认号，占4个字节，<font color="red">是期望收到对方下一个报文的第一个数据字节的序号</font>font&gt;。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，<font color="red">这表明B正确的收到了A发送的到序号700为止的数据</font>。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li><li>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li><li>保留，占6位，保留今后使用，但目前应都位0；</li><li>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li><li><strong>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</strong></li><li>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</li><li>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</li><li><strong>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</strong></li><li><strong>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</strong></li><li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li><li>检验和，占2字节，校验首部和数据这两部分；</li><li>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</li><li>选项，长度可变，定义一些其他的可选的参数。</li></ol><h3 id="TCP连接的建立（三次握手）"><a href="#TCP连接的建立（三次握手）" class="headerlink" title="TCP连接的建立（三次握手）"></a>TCP连接的建立（三次握手）</h3><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200522171030.gif" alt></p><div class="note info">            <p>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</p>          </div><ol><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了<strong>LISTEN（监听）</strong>状态；</li><li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 <strong>SYN-SENT（同步已发送状态）</strong>状态。<font color="red">TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号</font>。</li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了<strong>SYN-RCVD（同步收到）</strong>状态。<font color="red">这个报文也不能携带数据，但是同样要消耗一个序号</font>。</li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入<strong>ESTABLISHED（已建立连接）状态</strong>。<font color="red">TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</font>。</li><li>当服务器收到客户端的确认后也进入<strong>ESTABLISHED</strong>状态，此后双方就可以开始通信了。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200522172523.jpg" alt></p><h4 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h4><blockquote><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，<font color="red">客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了</font>，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p></blockquote><h3 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h3><div class="note info">            <p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</p>          </div><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200522172111.gif" alt></p><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入<strong>FIN-WAIT-1（终止等待1）状态</strong>。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了<strong>CLOSE-WAIT（关闭等待）</strong>状态。<font color="red">TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受</font>。<font color="blue">这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间</font>。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入<strong>FIN-WAIT-2（终止等待2）</strong>状态，等待服务器发送连接释放报文<font color="red">（在这之前还需要接受服务器发送的最后的数据）</font>。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了<strong>LAST-ACK（最后确认）</strong>状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了<strong>TIME-WAIT（时间等待）</strong>状态。<font color="red">注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态</font>。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。<font color="red">可以看到，服务器结束TCP连接的时间要比客户端早一些</font>。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200522172152.jpg" alt></p><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><blockquote><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，<font color="red">站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次</font>，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p></blockquote><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><blockquote><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p></blockquote><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><blockquote><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习—持久化</title>
      <link href="/posts/dcbcf729.html"/>
      <url>/posts/dcbcf729.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本篇介绍一下Redis的持久化机制</p><div class="note info">            <p>Redis是一种内存数据库，将自己的数据库状态（非空数据库以及它们的键值对）存储在内存中，为了防止丢失状态，Redis提供了持久化机制，将数据库状态保存到磁盘中，保存为dump.rdb文件。之后根据这个压缩的二进制文件，还能还原数据库状态。</p>          </div><h1 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h1><blockquote><p>我们安装完redis后，所有的配置都是在redis.conf文件中，里面保存了RDB和AOF两种持久化配置</p></blockquote><p>持久化有三种触发方式：SAVE命令、BGSAVE命令、自动化</p><ul><li>SAVE：可以生成RDB文件，但是同时会阻塞Redis服务器进行，使服务器不能处理任何命令</li><li>BGSAVE:会派生出一个子进程进行创建RDB文件的任务，服务器进程（父进程）继续处理命令。</li><li>自动化：允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200513233149.png" alt></p><p>打开<code>redis.conf</code>文件可以看到save选项配置：</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200513233529.png" alt></p><p>Redis服务器周期性操作函数<code>serverCron</code>默认每隔100毫秒就会执行一次，主要是对运行的服务器进行维护，其中一项工作就是检查save选项所配置的条件是否已经满足。</p><div class="note info">            <p>Redis数据库启动时检测到RDB文件存在后，会<strong>自动</strong>加载RDB文件</p>          </div><h2 id="SAVE与BGSAVE命令的区别"><a href="#SAVE与BGSAVE命令的区别" class="headerlink" title="SAVE与BGSAVE命令的区别"></a>SAVE与BGSAVE命令的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200513234254.png" alt></p><h2 id="RDB-文件结构"><a href="#RDB-文件结构" class="headerlink" title="RDB 文件结构"></a>RDB 文件结构</h2><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200513234745.png" alt></p><ul><li>REDIS:常量，表示是否是RDB文件</li><li>db_version：字符串，记录的是RDB版本号</li><li>databases:  包含零个或多个数据库</li><li>EOF：表示RDB文件正文已经结束</li><li>check_sum：表示一个校验和，检查载入文件时是否出错</li></ul><h2 id="RDB的优势和劣势"><a href="#RDB的优势和劣势" class="headerlink" title="RDB的优势和劣势"></a>RDB的优势和劣势</h2><p>优势：</p><ol><li>RDB文件紧凑，保存Redis服务器所有数据库中的数据，适用于备份和灾难恢复</li><li>生成RDB文件时，会生成一个子进程处理这个任务，不需要进行任何IO磁盘操作</li><li>RDB在恢复时比AOF恢复速度快</li></ol><p>劣势：</p><p>当子进程进行RDB文件持久化时，父进程也在处理Redis命令，而这些修改，子进程不会反映出来，可能丢失数据。</p><h1 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h1><p>如果说RDB是通过保存数据库中的<strong>键值对</strong>来记录数据库状态的不同，那么AOF持久化是通过保存Redis服务器执行的<strong>写命令</strong>来记录数据库状态的。</p><p>修改配置文件打开AOF功能：</p><blockquote><p>appendonly   yes</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200514001244.png" alt></p><p>由于AOF文件的更新频率通常比RDB更新频率高，所以程序会<strong>优先使用AOF</strong>，只有在AOF关闭时，才会用RDB</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200514000944.png" alt></p><h2 id="AOF持久化实现"><a href="#AOF持久化实现" class="headerlink" title="AOF持久化实现"></a>AOF持久化实现</h2><p>AOF持久化功能实现分三个步骤：命令追加、文件写入、文件同步</p><ol><li>命令追加</li></ol><p>当AOF持久化打开时，服务器执行完一个写命令之后，会将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾</p><ol start="2"><li>文件写入</li></ol><p><strong>Redis服务器进程</strong>是这样子：本身是一个事件循环（loop），循环中的文件时间负责接收客户端的命令请求，以及向客户端发送命令回复，而时间时间则负责执行类似serverCron函数（检查服务器运行状态）这类函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evenLoop</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理文件事件，接收命令请求以及发送命令回复</span></span><br><span class="line"><span class="comment"># 处理命令请求时可能会有新的内容被追加到aof_buf缓冲区内</span></span><br><span class="line">processFileEvents()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理时间事件</span></span><br><span class="line">processTimeEvents()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 考虑是否将aof_buf内容写入AOF文件</span></span><br><span class="line">flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><ol start="3"><li>文件同步</li></ol><p><code>flushAppendOnlyFile()</code>函数通过配置appendfsync选项来决定，有三种类型：</p><ul><li>always:    将aof_buf缓冲区所有内容写入并同步到AOF（文件完整性更好）</li><li>everysec:  将aof_buf缓冲区所有内存写入AOF，时隔1秒进行同步（每秒同步一次，可能会丢失一秒数据）</li><li>no: 将aof_buf缓冲区所有内存写入AOF，不进行同步，何时同步由操作系统定（不同步，效率高）</li></ul><h1 id="RDB与AOF区别"><a href="#RDB与AOF区别" class="headerlink" title="RDB与AOF区别"></a>RDB与AOF区别</h1><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200514002452.png" alt></p><p>AOF文件要大于RDB，相对的恢复速度就慢，而数据的安全性也相对较高。Redis默认使用RDB，我们要看情况选择合适的持久化方式</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习—过期机制</title>
      <link href="/posts/733001a7.html"/>
      <url>/posts/733001a7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本节我们来讲一下Redis的过期机制</p><div class="note info">            <p>Redis经常用作缓存，很多都是临时缓存，比如验证码等session信息，我们希望它们能在一定时间内自动销毁。Redis提供了一些对key设置过期时间的命令。</p>          </div><h1 id="一、过期字典"><a href="#一、过期字典" class="headerlink" title="一、过期字典"></a>一、过期字典</h1><p>Redis对存储值的过期处理实际上是对键（key）设置过期时间，然后到期自动删除这个键。</p><p>我们要知道在redis数据库的结构设计中，是采用<strong>expires字典</strong>保存了数据库中所有键的过期时间，被称为<code>过期字典</code></p><ul><li>过期字典的键是一个指针，指向键空间中的某个键对象（设置过期时间的键对象）</li><li>过期字典的值是一个long long 类型的整数，保存了一个毫秒精度UNIX时间戳的过期时间</li></ul><p>当一个数据库键设置过期时间时，服务器会在过期字典中关联指定的数据库键和过期时间</p><h1 id="二、设置键的过期时间"><a href="#二、设置键的过期时间" class="headerlink" title="二、设置键的过期时间"></a>二、设置键的过期时间</h1><p>设置数据库键的过期时间有以下几种命令：</p><ul><li>EXPIRE key time 设置生存时间为time秒</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200511175647.png" alt></p><ul><li><p>PEXPIRE key time 设置生存时间为time 毫秒</p></li><li><p>EXPIREAT key timestamp 设置过期时间为timestamp指定的时间戳</p></li><li><p>PEXPIREAT key timestamp 设置过期时间，单位为毫秒</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200511182129.png" alt></p><blockquote><p>键的生存时间  =  过期时间 - 当前时间</p></blockquote><p>上面的四条命令最终都会转换为<font color="red">PEXPIREAT</font>命令来实际实现</p><blockquote><p>EXPIRE –&gt;PEXPIRE–&gt;PEXPIREAT</p><p>EXPIREAT –&gt;PEXPIREAT</p></blockquote><p>还有一种<code>SETEX key &quot;seconds&quot; &quot;value&quot;</code>专门用于给字符串键设置过期时间</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200511184514.png" alt></p><ul><li>TTL key 获取key的过期时间（秒）</li><li>PTTL key 获取key的过期时间（毫秒）</li></ul><h1 id="三、-过期键删除策略"><a href="#三、-过期键删除策略" class="headerlink" title="三、 过期键删除策略"></a>三、 过期键删除策略</h1><p>我们根据过期时间来判断一个键是否过期，如果一个键过期了，那么它什么时候被删除呢？Redis提供三种不同的删除策略：</p><ul><li><strong>定时删除</strong>：在设置键的过期时间同时，创建一个定时器timer，过期时间来临时，就立马删除</li><li><strong>惰性删除</strong>：放任过期时间不管，只有当每次从键空间获取键时，检查是否过期，如果过期就删除该键；没有过期就返回该键</li><li><strong>定期删除</strong>：每隔一段时间，程序对数据库进行一次检查，删除里面的过期键</li></ul><p>定时删除的缺点：对CPU时间是不友好的，在过期键较多的情况下，删除过期键可能会占用相当一部分CPU时间，而且创建定时器很耗时，但它又是对内存是最友好的。</p><p>惰性删除的缺点：对内存不友好的，因为过期的键会保留在数据库中，只要是过期键不被删除，它所占用的空间就不会释放。</p><p>定期删除的难点就是确定删除操作执行的时长和频率。</p><h1 id="四、Redis采用的过期删除策略"><a href="#四、Redis采用的过期删除策略" class="headerlink" title="四、Redis采用的过期删除策略"></a>四、Redis采用的过期删除策略</h1><p><strong>惰性删除+定期删除</strong></p><ul><li><p>惰性删除：</p><p>在读写数据库的Redis命令之前会执行调用<code>expireIfNeeded</code>函数对输入键进行检查：</p><ul><li>如果输入键已经过期，那么<code>expireIfNeeded</code>函数会将输入键删除</li><li>如果未过期就不动作</li></ul><p>而且在之前还要检查键是否存在</p></li><li><p>定期删除：</p><p>遍历各个数据库（默认数据库的数量是16），检查当前库中的指定数量的key（默认每个库检查20个key）</p><ul><li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的检查</li><li><strong>随机获取</strong>一个带有过期时间的键，如果已经过期，就删除它</li><li>判断是否已达到<strong>时间上限</strong>，停止</li></ul></li></ul><h1 id="五、RDB对过期key的处理"><a href="#五、RDB对过期key的处理" class="headerlink" title="五、RDB对过期key的处理"></a>五、RDB对过期key的处理</h1><p>过期key对RDB没有任何影响</p><ul><li>从内存数据库持久化数据到RDB文件<ul><li>持久化key之前，会检查是否过期，过期的key不进入RDB文件</li></ul></li><li>从RDB文件恢复数据到内存数据库<ul><li>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</li></ul></li></ul><h1 id="六、AOF对过期key的处理"><a href="#六、AOF对过期key的处理" class="headerlink" title="六、AOF对过期key的处理"></a>六、AOF对过期key的处理</h1><p>过期key对AOF没有任何影响</p><ul><li>从内存数据库持久化数据到AOF文件：<ul><li>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）</li><li>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）</li></ul></li><li>AOF重写<ul><li>重写时，会先判断key是否过期，已过期的key不会重写到aof文件 </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找法总结（几种模板）</title>
      <link href="/posts/e360070f.html"/>
      <url>/posts/e360070f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>二分查找法初始是在<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704题二分查找</a>，详细总结在<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">这里</a>。</p><p>下面我来总结一下常见的二分查找法模板：</p><h3 id="第一种-while-left-lt-right"><a href="#第一种-while-left-lt-right" class="headerlink" title="第一种 while(left&lt;=right)"></a>第一种 while(left&lt;=right)</h3><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200509104038.png" alt></p><p>这种实际上把区间分成了三部分，最常见写法</p><p>优点是：</p><ul><li>思路直接，找到目标值就退出</li></ul><p>缺点是：</p><ul><li>如果搜索区间数组有多个值和目标值相等，还要判断边界，比较麻烦</li><li>退出循环时，我们要思考返回left还是right还是..</li></ul><p>代码模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">left = mid +<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意取中间值时的写法</strong>：不要写成(left + right) / 2,因为当left 和right都是很大的数是会出现溢出。所以写成<code>mid = left + (right - left)/2;</code>可以避免溢出。或者写成<code>int mid = (left + right) &gt;&gt;&gt;1;</code>  &gt;&gt;&gt;表示无符号右移，这样如果溢出了也能得到正确的结果</p><h3 id="第二种-while-left-lt-right-（排除法）"><a href="#第二种-while-left-lt-right-（排除法）" class="headerlink" title="第二种 while(left &lt; right)（排除法）"></a>第二种 while(left &lt; right)（排除法）</h3><p>二分查找法还有很多扩展问题，用上面的方法可能还要判断边界，比较麻烦</p><ol><li>在有序数组中查找等于目标元素的第1个索引或者最后1个下标；</li><li>在有序数组中查找第1个大于（等于）目标元素的下标；</li><li>在有序数组中查找第1个小于（等于）目标元素的下标；</li><li>在有序数组中查找最后1个大于（等于）目标元素的下标；</li><li>在有序数组中查找最后1个小于（等于）目标元素的下标；</li></ol><hr><p>我们考虑一种<strong>“排除法”</strong>（减治思想）的方法—<strong>考虑中间元素nums[mid]在什么情况下不是目标值</strong></p><ul><li>思路是：将待搜索区间分成2部分，一部分一定不存在目标元素，另一部分可能存在目标元素</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200509110410.png" alt></p><p>整体做法是：</p><ul><li><p>1 先写循环继续条件<code>while(left &lt; right)</code> 终止的时候一定有<code>left == right</code>成立，所以返回left还是right都可以<strong>（注意：最后返回的left或right位置的值还没取到，可能还要对这个位置的值是否是目标值做一次判断）</strong></p></li><li><p>2 写if else语句的时候，思考当nums[mid]满足什么性质时，<strong>nums[mid]不是目标元素</strong>，然后判断mid的左边有没有可能存在目标元素，右边有没有可能存在目标元素</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200509111748.png" alt></p></li></ul><p>边界收缩行为有两种：</p><p>第一种：mid被分到左边，区间被分为<code>[left, mid]</code> 和<code>[mid+1, right]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">    <span class="comment">// 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置</span></span><br><span class="line">    right = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：mid被分到右边，区间被分为<code>[left , mid -1]</code> 和 <code>[mid , right]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3 根据“边界收缩行为”修改取中间数的行为（重难点）</li></ul><p>上面我们讲了中间数的写法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left + (right- left) /<span class="number">2</span></span><br></pre></td></tr></table></figure><p>但是这种写法在边界收缩行为的第二种 mid被分到右边时 会出现问题！！</p><p><strong>由于“/”是下取整，所以永远取不到右边界</strong>（举个例子：数组只剩两个元素[3,4]的时候，取不到4这个值），所以<font color="red">可能</font>会出现死循环</p><p>遇到死循环时，不要慌张，只要记住：</p><blockquote><p>在到边界left ==mid时， 取中间数+1，改成向上取整即可</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200509113700.png" alt></p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><strong>一、在数组中查找符合条件的元素的索引</strong></p><table><thead><tr><th align="center">题目</th><th>提示与题解</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></td><td>二分查找的模板问题，使用本题解介绍的方法就要注意，需要“后处理”。</td></tr><tr><td align="center"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></td><td>查找边界问题，<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/" target="_blank" rel="noopener">题解（有视频讲解）</a>。</td></tr><tr><td align="center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/" target="_blank" rel="noopener">题解</a></td></tr><tr><td align="center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td align="center"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td align="center"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td align="center"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></td><td>二分查找的思路需要理解，代码很像第 35 题，<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td align="center"><a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">275. H指数 II</a></td><td><a href="https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr><tr><td align="center"><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></td><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td align="center"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个有序数组的中位数</a></td><td>二分搜索中最难的问题之一，建议先弄清楚解题思路，<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td align="center"></td><td></td></tr></tbody></table><p><strong>二、在一个有上下界的区间里搜索一个整数</strong></p><table><thead><tr><th>题目</th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. 平方根</a></td><td>在一个整数范围里查找一个整数，也是二分查找法的应用场景，<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></td><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">题解</a>。在一个整数范围里查找一个整数。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/" target="_blank" rel="noopener">题解</a></td></tr><tr><td></td><td></td></tr></tbody></table><p><strong>三、判别条件是一个函数</strong></p><table><thead><tr><th>题目</th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></td><td>经典问题，判别函数的写法很有技巧。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素</a></td><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></td><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/solution/er-fen-cha-zhao-ding-wei-su-du-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机第七章—虚拟机类加载机制</title>
      <link href="/posts/2e913e33.html"/>
      <url>/posts/2e913e33.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="本章常见面试题"><a href="#本章常见面试题" class="headerlink" title="本章常见面试题"></a>本章常见面试题</h1><ul><li>类加载机制的过程（五个阶段）</li><li>什么是双亲委派模型？</li><li>讲讲类加载器？</li></ul><h1 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h1><p>在开始本章之前，你需要了解Class文件的存储格式，Java虚拟机在编译的时候将Java程序编译成Class文件，Java虚拟机只与<code>Class文件</code>这种特定的二进制文件格式关联，Class文件中包含了Java虚拟机指令集、符号表等信息</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200430160813.jpg" alt></p><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按顺序紧凑排列在文件中，中间没有添加任何分隔符。</p><p>Class文件包含两种数据类型：<strong>无符号数</strong> 和 <strong>表</strong></p><p>无符号数：表示的是基本数据类型，以u1、u2、u4、u8表示1个字节、2个字节、4个字节和8个字节</p><p>表：表示是有多个无符号数或者其他表作为数据项构成的符合数据类型，以”_info”结尾</p><p>Class文件头4个字节被称为<strong>魔数</strong>，是<code>0xCAFEBABE</code>（咖啡宝贝？），后4个字节存储的是Class文件的版本号：5，6个字节是次版本号，7，8个字节是主版本号</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200430161946.jpg" alt></p><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>一个类从被加载到虚拟机内存中开始，到卸载出内存为止，整个周期为：<code>加载、验证、准备、解析、初始化、使用、卸载</code>七个阶段，验证、准备、解析这三个阶段统称为连接🔗</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200430163454.jpg" alt></p><p>对于Java虚拟机而言，以下六种情况必须对类进行<strong>初始化</strong>：</p><ul><li><ol><li><p>使用new关键字实例化对象的时候</p></li><li><p>读取或设置一个类型的静态字段(除了被final修饰、已在编译期就把结果放入常量池的静态字段)</p></li><li><p>调用一个静态类型方法的时候</p></li></ol></li><li><p>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有被初始化，要先初始化</p></li><li><p>当初始化类的时候，如果发现其父类还没初始化，先触发父类</p></li><li><p>虚拟机启动时，用户指定的那个执行的主类(包含main()方法的类)先初始化</p></li><li><p>使用JDK1.7 动态语言的时候，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p></li><li><p>JDK1.8新加入的默认方法（被default关键字修饰的接口方法），如果这个接口的实现类发生了初始化，该接口也要在之前被初始化</p></li></ul><p><strong>被动引用</strong>：所有引用类的方式都不会触发初始化的方式：</p><p><strong>（1）通过子类引用父类的静态字段，不会导致子类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类的静态字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过子类引用父类的静态字段，不会导致子类的初始化</span></span><br><span class="line">System.out.println(SubClass.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：”SuperClass init!”不会引发子类的初始化</p><p><strong>（2）通过数组定义来引用类，不会出触发此类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过数组定义引用类，不会触发此类的初始化</span></span><br><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//通过new创建对象，可以触发初始化</span></span><br><span class="line"><span class="comment">//SuperClass superClass = new SuperClass();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.printlen(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口的初始化</strong>与类初始化的区别：</p><p>一个类初始化要求其父类全部都已经初始化过了，但一个接口在初始化时，并不要求父接口全部完成了初始化，只有帧栈使用到父接口（如引用接口中定义的常量）时，才会初始化</p><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>类加载包括 加载、验证、准备、解析和初始化</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>Java加载过程是整个<code>类加载</code>的一个阶段，包含：</p><ul><li>通过一个类的<strong>全限定名</strong>(将类全名路径的.全部替换成/,比如: <code>me/cglib/SampleClass</code>)来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li></ul><p>Java虚拟机获取的是二进制字节流，可有很多来源：</p><ul><li>从ZIP压缩包读取，JAR包等格式</li><li>从网络中获取，Web Applet</li><li>动态代理，在运行时计算生成，代理$Proxy</li><li>由其他文件生成，JSP文件生成对应的Class文件</li><li>从数据库中读取，比如某些中间件服务器(SAP Netweaver)</li><li>从加密文件中获取</li></ul><p>对于非数组类加载可以由虚拟机内置的<strong>引导类加载器</strong>完成，也可以由<strong>用户自定义的类加载器</strong>（重写一个类加载器的<code>findClass()</code>或<code>loadClass()</code>方法）完成。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><strong>验证是连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合规范，不会危害虚拟机自身的安全</strong></p><p>由于之前讲的Class文件并不一定只是由Java源码编译而来，所以如果不检查输入的字节流，很可能因为载入了错误或有恶意企图的字节码流而导致整个系统受攻击和崩溃</p><p>验证阶段大致完成四个阶段的校验：<strong>文件格式验证、元数据验证、字节码验证、符号引用验证</strong></p><h3 id="1-文件格式验证"><a href="#1-文件格式验证" class="headerlink" title="1.文件格式验证"></a>1.文件格式验证</h3><p>第一阶段要验证字节流是否符合Class文件格式的规范</p><ul><li>是否以魔数<code>0xCAFEBABE</code>开头</li><li>主、次版本号是否在当前Java虚拟机接收范围内</li><li>常量池的常量中是否有不被支持的常量类型</li><li>指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量</li></ul><p>满足第一阶段的验证后，这段字节流才允许进入Java虚拟机内存的方法区中存储，所以<strong>后面三个阶段 全部是基于方法区的存储结构上进行</strong></p><h3 id="2-元数据验证"><a href="#2-元数据验证" class="headerlink" title="2.元数据验证"></a>2.元数据验证</h3><p>第二阶段是对字节码描述的信息进行语义分析，对<strong>元数据信息的数据类型</strong>进行校验，包括：</p><ul><li>该类是否有父类（除了<code>java.lang.Object</code>之外）</li><li>该类是否继承了不允许被继承的类（被final修饰的类）</li><li>如果该类不是抽象类，是否实现了其父类或接口中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾</li></ul><h3 id="3-字节码验证"><a href="#3-字节码验证" class="headerlink" title="3.字节码验证"></a>3.字节码验证</h3><p>第三阶段主要目的是通过数据流分析和控制流分析，确定程序语义是合法的。</p><p><strong>对类的方法体（Class文件中的Code属性）校验分析</strong></p><ul><li>保证不会出现比如在操作数栈放置了一个int类型数据，使用时却按long类型加载入本地变量表中</li><li>保证任何跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转化总是有效的</li></ul><p>由于数据流分析和控制流分析的高度复杂性，为提高性能，在JDK 6 之后在方法体Code属性的属性表中新增了一项<code>StackMapTable</code>属性，这项属性描述了方法体所有的基本块，只要检查<code>StackMapTable</code>属性中的记录是否合法即可</p><h3 id="4-符号引用验证"><a href="#4-符号引用验证" class="headerlink" title="4.符号引用验证"></a>4.符号引用验证</h3><p>最后一个验证发生在虚拟机将符号引用转化为直接引用时，这个转化动作发生在连接的第三阶段—解析阶段中发生，需要验证：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符</li><li>符号引用中的类、字段、方法的可访问性(public,private,protected)是否可被当前类访问</li></ul><p>符合引用的目的主要是保证解析行为能正常执行</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是<strong>正式为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始值的阶段</strong>，注意：</p><ul><li><p>这时内存分配的类变量，不包括实例变量，实例变量会在对象实例化的时候随着对象一起分配在<strong>堆</strong>中</p></li><li><p>这里的初始值，通常情况下是数据类型的零值</p><table><thead><tr><th>数据类型</th><th>零值</th><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td><td>boolean</td><td>false</td></tr><tr><td>long</td><td>0L</td><td>float</td><td>0.0f</td></tr><tr><td>short</td><td>(short) 0</td><td>double</td><td>0.0d</td></tr><tr><td>char</td><td>‘\u000’</td><td>reference</td><td>null</td></tr><tr><td>byte</td><td>(byte) 0</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li><p>特殊情况的初始化：类字段的字段属性存在ConstantValue属性，那么会被初始化指定的值</p><blockquote><p>public static <strong>final</strong> int value = 123;</p></blockquote></li></ul></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是<strong>Java虚拟机将常量池中的符号引用替换成直接引用的过程</strong></p><ul><li><strong>符号引用</strong>：是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标即可（比如字符串的字面量）。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到内存中的内容。</li><li><strong>直接引用</strong>：是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。与虚拟机实现的内存布局有关，引用目标必须是已经在内存中存在的。</li></ul><h3 id="解析结果缓存"><a href="#解析结果缓存" class="headerlink" title="解析结果缓存"></a>解析结果缓存</h3><p>对同一符号引用进行多次解析请求是很常见的事情，除invokedynamic指令外，虚拟机实现可以对第一次解析的结果进行缓存，例如运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。</p><p>无论是否真正执行多次解析动作，Java虚拟机都需要保证在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能成功；同样的，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常。</p><p>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>这7类符号引用进行</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类的初始化阶段是类加载过程的最后一个步骤，这个阶段Java虚拟机才真正开始执行类中编写的Java程序代码，<strong>将主导权转移给应用程序</strong>。之前的几个类加载动作，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余都完全由Java虚拟机来主导控制</p><p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，这个方法是Javac编译器自动生成的</p><h3 id="clinit-方法和类的构造函数的区别"><a href="#clinit-方法和类的构造函数的区别" class="headerlink" title="clinit()方法和类的构造函数的区别"></a>clinit()方法和类的构造函数的区别</h3><p>clinit方法是出现在类加载过程的初始化阶段，init方法出现在类实例化时调用的(Java编译后，会在字节码中生成init方法，就是类的构造函数方法)</p><p>clinit()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块(static{}块)</p><p>init方法（实例构造器init()方法）是在类实例化时调用</p><p><code>&lt;clinit&gt;()方法</code>不需要显式地调用父类构造器，Java虚拟机会保证在子类的clinit()方法执行前，父类的clint()方法已经执行完毕</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确定其在java虚拟机的唯一性。<strong>如果两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载他们的类加载器不同，那么这两个类就必不相等。</strong></p><h2 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h2><p>从Java虚拟机角度来看，只存在两种不同的类加载器:<strong>启动类加载器(Bootstrap ClassLoader)</strong>，使用C++语言实现，是虚拟机自身的一部分；另一个是<strong>其他所有类加载器</strong>，由Java语言实现，独立存在于虚拟机外部，全都继承自抽象类java.lang.ClassLoader</p><p>这里我们介绍三种系统提供的类加载器：</p><p><strong>启动类加载器（Bootstrap ClassLoader）</strong>:</p><p>这个类记载器负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，能被虚拟机识别的类库(按照文件名识别，如rt.jar、tools.jar等)加载到虚拟机内存</p><p><strong>扩展类加载器（Extension ClassLoader）：</strong></p><p>这个类加载器负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。这是一种Java系统类库的扩展机制，可以在程序中使用该加载器来加载Class文件</p><p><strong>应用程序类加载器（Application ClassLoader）：</strong></p><p>这个类加载器负责加载用户类路径(ClassPath)上所有的类库，也被称为’系统类加载器’。<strong>如果应用程序没有自定义过自己的类加载器，那么这个就是程序中默认的类加载器</strong></p><p>我们的应用程序都是由这3种类加载器互相配合来完成加载，如果用户认为有必要，还可以加入自定义的类加载器来进行扩展</p><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200505144848.png" alt></p><p>双亲委派模型反映的是各种类加载器之间的层次关系，他们之前是相互合作的。</p><p>除了顶层的启动类加载器外，其余的类加载器应有自己的父类加载器，不过这种父子关系不是通过继承来实现，而是一种组合关系</p><p><strong>工作流程</strong>是： <strong>如果一个类加载器收到了类加载的请求，先把这个请求委派给父类加载器去完成（所以所有的加载请求最终都应该传送到顶层的启动类加载器中），只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。</strong></p><p>这样的好处就是保证了一种带有优先级的层次关系，比如java.lang.Object类，无论哪一个类加载器都要先加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境种都能保证是同一个类。</p><p>来看个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//1 首先检查类是否被加载</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">//2 没有则调用父类加载器的loadClass()方法；</span></span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//3 若父类加载器为空，则默认使用启动类加载器作为父加载器；</span></span><br><span class="line">                c = findBootstrapClass0(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           <span class="comment">//4 若父类加载失败，抛出ClassNotFoundException 异常后</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        <span class="comment">//5 再调用自己的findClass() 方法。</span></span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇介绍了类加载过程中的五个阶段：加载、验证、准备、解析、初始化，还介绍了几种不同的类加载以及之间的合作关系—双亲委派模型</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE部分 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高级知识 </tag>
            
            <tag> 虚拟机类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机第三章—垃圾收集器</title>
      <link href="/posts/3dc2e517.html"/>
      <url>/posts/3dc2e517.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h1><ul><li><p>引用计数法：在对象中加一个引用计数器，被引用一次计数器值+1，失效计数器-1，减为0对象死亡。容易出现两个对象互相引用导致无法回收的问题</p></li><li><p>可达性分析：从一系列GC Roots的根对象为起始结点，从结点向下根据引用关系搜索。</p><p>固定可作为GC Roots的对象包括：</p><ol><li>虚拟机栈(帧栈的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>本地方法栈JNI引用的对象</li><li>Class对象</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Person a = <span class="keyword">new</span> Person();<span class="comment">//方法区中类的静态属性引用的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String s = <span class="string">"abc"</span>;<span class="comment">//方法区中常量引用的对象</span></span><br><span class="line">Person b = <span class="keyword">new</span> Person();        <span class="comment">//栈中本地方法表引用的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h1><p><strong>强引用：</strong> Object obj = new Object()类似 永远不会回收掉</p><p><strong>软引用：</strong>非必须对象。在系统要发生内存溢出异常前，会对这些对象进行回收，如果还没有足够的内存，才会抛出内存溢出异常。 SoftReference类来实现软引用</p><p><strong>弱引用：</strong>非必须对象。被弱引用对象只能生存到下一次垃圾收集发生为止。WeakReference类来实现弱引用。</p><p><strong>虚引用：</strong>是最弱的一种引用关系，无法通过虚引用获取一个对象实例，唯一目的就是在这个对象被回收时收到一个系统通知。</p><h1 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h1><p>方法区主要存放永久代的对象，而永久性对象的回收率比新生代低很多，性价比不高。</p><p>方法区主要对<strong>常量池回收</strong>、<strong>类的卸载</strong></p><p>满足三个条件才对类进行卸载：</p><ul><li>类的所有实例已经被回收</li><li>加载该类的类加载器已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用</li></ul><p><strong>finalize()方法</strong>(已不推荐使用)：</p><p>一个对象被判断为死亡要至少经过两次标记：</p><p>第一次是在可达性分析后发现没有与GC Roots相连的引用链，这是第一次标记。随后对这些对象进行一些筛选，看是否有必要执行finalize方法。筛选的条件是：对象是否覆盖finalize()方法或者finalize（）方法已被调用过一次。</p><p>需要执行finalize方法的对象被装入F-Queue队列中，在finalize方法中只要该对象重新与引用链上对象关联，就实现了自我拯救，在第二次标记时被移除队列。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>首先根据对象的存活周期不同，内存分为几部分：</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200424150737.png" alt></p><h2 id="标记清除-Mark-Sweep-算法"><a href="#标记清除-Mark-Sweep-算法" class="headerlink" title="标记清除(Mark-Sweep)算法"></a>标记清除(Mark-Sweep)算法</h2><p>最基础的算法是标记清除算法，整个算法分为两个阶段：标记、清除。</p><p>首先标记所有需要回收对象，然后标记完成后，统一回收。</p><p>缺点是：</p><ul><li>执行效率不稳定：如果有大量对象要回收效率降低</li><li>内存空间碎片化</li></ul><h2 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h2><p>主要思想是将内存分为相等两块，当一块内存用完了，将还存活的对象复制到另一块上面，再把已使用过的内存空间一次清理掉。</p><p>由于新生代对象具有”朝生夕灭”的特点，虚拟机将内存空间分为一块较大的Eden空间和两块较小的Survivor空间，默认比例是8:1</p><p>每次垃圾收集只使用Eden和其中一块Survivor，将活着的对象复制到另一块Survivor上面。</p><p><code>PS:</code>如果每次回收活着的对象超过10%怎么办？</p><p>答：有一个逃生门设计：当Survivor空间不足以容纳存活对象时，这些对象通过<code>分配担保机制</code>直接进入老年代</p><h2 id="标记整理算法-老年代"><a href="#标记整理算法-老年代" class="headerlink" title="标记整理算法(老年代)"></a>标记整理算法(老年代)</h2><p>标记整理算法区别与标记复制算法，因为老年代存活的对象很多，复制算法不适合这种情况。</p><p>标记阶段和’标记-清除’算法一致，之后将所有活的对象都向内存一段移动（这种移动对象必须全程暂停用户程序，被称为“stop the world”）</p><p>缺点：</p><ul><li>移动对象内存回收效率变低</li></ul><p>移动对象整个垃圾回收停顿时间⬆,延迟增加，但吞吐量⬆</p><p>不移动对象停顿时间⬇,延迟减小，但吞吐量⬇</p><h1 id="几种垃圾收集器"><a href="#几种垃圾收集器" class="headerlink" title="几种垃圾收集器"></a>几种垃圾收集器</h1><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200424162002.png" alt></p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial （新生代）/ Serial Old （老年代）：</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200424161922.jpg" alt></p><ul><li>新生代收集器</li><li>复制算法</li><li>单线程，垃圾收集时暂停应用程序</li><li>与Serial Old收集器组合</li><li>一般运行在客户端，部分微服务领域没有过多线程交互</li></ul><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew （新生代）/ CMS（老年代）</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200424162546.png" alt></p><p>是Serial的多线程并行版本</p><ul><li>新生代收集器</li><li>复制算法</li><li>目前唯一与CMS收集器配合的</li><li>运行在服务器端</li></ul><h2 id="Paraller-Scavenge-收集器"><a href="#Paraller-Scavenge-收集器" class="headerlink" title="Paraller Scavenge 收集器"></a>Paraller Scavenge 收集器</h2><p>是一款专注于吞吐量的新生代收集器</p><p>吞吐量：<br>$$<br>吞吐量 = {运行用户代码时间 \over 运行用户代码时间+垃圾收集时间}<br>$$<br>提供两个参数来精确控制吞吐量：</p><p>最大垃圾收集停顿时间 <code>-XX:MaxGCPauseMillis</code>、吞吐量大小 <code>-XX:GCTimeTatio</code></p><p>最大垃圾收集停顿时间不是越小垃圾收集的就越快，它是以牺牲吞吐量和新生代空间。</p><p>Paraller Scavenge收集器还有一个开关参数 <code>-XX:+UseAdaptiveSizePolicy</code>，它可以自适应调节新生代大小、Eden与Survivor比例、老年代对象大小等</p><hr><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><ul><li>Serial的老年代版本</li><li>标记-整理算法</li><li>运行在客户端</li></ul><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><ul><li>Parallel Scavenge 的老年代版本</li><li>标记-整理算法</li><li>与Parallel Scavenge配合，以’吞吐量优先’</li><li>运行在服务器端，保证吞吐量</li></ul><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS(Concurrent Mark Sweep)是以<strong>获取最短回收停顿时间</strong>为目标的收集器，与ParNew收集器配合。</p><p>它基于标记-清除算法，包含几个步骤：</p><ul><li><p>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</p></li><li><p>并发标记：从GC Roots能关联到的对象开始遍历整个对象图</p></li><li><p>重新标记：修正并发标记阶段用户程序运行导致标记变动的记录</p></li><li><p>并发清除：清除掉标记阶段判定已死亡的对象</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200424172438.png" alt></p><p>缺点：</p><ul><li>并发阶段，虽然不会导致用户线程停顿，但却占用一部分线程导致应用程序变慢，降低总吞吐量</li><li>无法处理<code>浮动垃圾</code>(存在于并发阶段程序额外产生的垃圾)，可能预留的内存不够存放浮动垃圾，导致<code>并发失败</code>进而导致Full GC的产生，这时虚拟机会临时启用Serial Old 代替CMS</li><li>标记-清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1收集器是垃圾收集器技术的里程碑式结果，在JDK9发布之时，G1宣告成为服务器端的默认垃圾收集器，目的是取代CMS收集器</p><p>G1设计的初衷是要一款能够建立<code>可预测的停顿时间模型</code>，意思是能支持指定在一个时间片内进行垃圾收集。</p><p>G1不再像其他垃圾收集器只收集新生代(Minor GC)或者只收集老年代(Major GC)或者整个堆全部收集(Full GC)，而是采用Mixed GC模式，哪块内存中垃圾数量多，回收收益大就收集。</p><p>G1收集器是追踪各个Region里面垃圾堆积的’价值’大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后维护一个优先级列表，每次根据用户设定允许的收集停顿时间(通过<code>-XX:MaxGCPauseMillis</code>指定)，优先处理回收价值最大的Region</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200424204622.png" alt></p><h3 id="分区-Region"><a href="#分区-Region" class="headerlink" title="分区 Region"></a>分区 Region</h3><p>G1采用了分区的思路，将整个堆空间分成若干个大小相等的内存区域，每个内存区域可以根据需要，扮演新生代Eden空间，Survivor空间或者老年代空间。并不要求对象的存储一定是物理上的连续，只要逻辑上连续即可</p><h3 id="卡片-Card"><a href="#卡片-Card" class="headerlink" title="卡片 Card"></a>卡片 Card</h3><p>在每个分区内部又被分成若干大小512 Byte卡片(Card),标识堆内存最小可用粒度所有分区的卡片会记录在 全局卡片表(Global Card Table)中，分配的对象会在物理上占用连续若干个卡片</p><h3 id="Humongous区域"><a href="#Humongous区域" class="headerlink" title="Humongous区域"></a>Humongous区域</h3><p>Humongous区域专门用来存储大对象（超过了一个Region容量一半的对象），如果超过了整个Region容量的超级大对象，会被存放在N个连续Humongous区域中，Humongous Region被当作老年代的一部分</p><h3 id="已记忆集合-Remember-Set"><a href="#已记忆集合-Remember-Set" class="headerlink" title="已记忆集合 Remember Set"></a>已记忆集合 Remember Set</h3><p>每个Region都维护一个自己的记忆集RSet，这些记忆集内部类似一个反向指针，记录别的Region指向自己的指针，并标记分别在哪些卡页范围内。</p><h3 id="G1解决的3个问题"><a href="#G1解决的3个问题" class="headerlink" title="G1解决的3个问题"></a>G1解决的3个问题</h3><ul><li><p>对象跨Reigon(代)引用问题：</p><p>假设进行一次只局限于新生代区域内的收集，但新生代中的对象很可能被老年代所引用，为了找出老年代中存活对象，必须还要额外遍历整个老年代中所有对象保证可达性结果的正确，增加很多内存负担。</p><p><strong>解决方案：</strong>每个Reigon区域维持记忆集，避免扫描所有区域</p></li><li><p>并发标记阶段如何保证收集线程和用户线程互不干扰？</p><p>并发标记阶段时用户线程会改变对象引用关系，但必须保证原本的对象图不能被打破，导致标记出错。</p><p><strong>解决方案：</strong>CMS采用增量更新算法实现，而G1收集器采用<a href="#原始快照算法">原始快照(SATB)算法</a>实现。此外，G1为每一个Region设计两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中新对象的分配，并发回收时新分配对象地址要在两个指针位置以上</p></li></ul><h2 id="运行步骤"><a href="#运行步骤" class="headerlink" title="运行步骤"></a>运行步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200424232822.png" alt></p><ul><li>初始标记：标记GC Roots能直接关联到的对象，并修改TAMS指针的值</li><li>并发标记：扫描对象图，之后重新处理SATB记录下的有引用变动的对象</li><li>最终标记：对用户线程短暂暂停，处理最后少量的SATB记录</li><li>筛选回收：根据用户期望停顿时间来制定回收计划，将存活对象复制到空的Region中，再清理掉旧Region全部空间</li></ul><h1 id="几种概念解析"><a href="#几种概念解析" class="headerlink" title="几种概念解析"></a>几种概念解析</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p><strong>并行：</strong>描述的是多条垃圾收集器线程之间的关系。指同一时间有多条线程在协同工作</p><p><strong>并发：</strong>描述的是垃圾收集器与用户线程之间的关系。指同一时间垃圾收集器线程与用户线程都在运行</p><h2 id="原始快照算法"><a href="#原始快照算法" class="headerlink" title="原始快照算法"></a><a name="原始快照算法">原始快照算法</a></h2>]]></content>
      
      
      <categories>
          
          <category> JavaSE部分 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高级知识 </tag>
            
            <tag> 垃圾收集器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题折腾记录</title>
      <link href="/posts/ae32e687.html"/>
      <url>/posts/ae32e687.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">            <p>本文记录一些主题自改的一些小改动，你可以get:</p><ol><li>自定义样式的修改</li><li>插件的总结</li></ol><p>自己没怎么学过前端的知识，好多都是瞎折腾，有错误请指正！</p>          </div><p>说起主题，我前前后后用过有Next、Matery到现在的Butterfly。</p><p>刚开始Next主题是我搭建博客的最开始用的，黑白简约，功能也很多，但是缺点也是整体感觉太单调和不扁平化，然后我又网上看到了Matery主题(这种卡片式的博客一下子就吸引到我了)，接触了很多修改主题的方式，还加了群，群里小伙伴真的是很nice啊！</p><p>折腾了又一阵，我觉得Matery主题也有一些不方便，不太容易快速查找博客，分类、标签不直接，现在用了Butterfly，可玩性很高！开发主题的大佬居然和自己的年龄也差不多(差距啊:sob:),下面记录一下自己折腾的记录：</p><h3 id="鼠标特效"><a href="#鼠标特效" class="headerlink" title="鼠标特效"></a>鼠标特效</h3><p>鼠标拖动掉星星效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200415233821.gif" alt></p><ol><li><p>在<code>themes/Butterfly/source/js/third-part</code>目录下新建<code>cursor.js</code>文件，文件的网址<a href="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.1.7/source/js/cursor.js" target="_blank" rel="noopener">传送门</a>，将里面的内容复制到cursor.js中即可。</p></li><li><p>在主题配置文件<code>butterfly.yml</code>CDN处的<code>ClickShowText</code>后面加上一句 <code>/js/third-party/cursor.js</code> 引入js地址</p></li><li><p>打开<code>themes/Butterfly/layout/includes</code>目录下的<code>additional-js.pug</code>文件,在鼠标特效的下面位置处添加代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.cursor &amp;&amp; theme.cursor.enable</span><br><span class="line">  script(src=url_for(theme.CDN.cursor)</span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件butterfly.yml中鼠标特效的地方开启我们的特效开关</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cursor:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="文章日历"><a href="#文章日历" class="headerlink" title="文章日历"></a>文章日历</h3><p>想在侧边栏实现文章日历📅的效果，可以记录发布文章的日期和频率，这里就要用到<code>hexo-generator-calendar</code>插件</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200416203448.PNG" alt></p><ol><li><p>安装<code>hexo-generator-calendar</code>插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install git://github.com/howiefh/hexo-generator-calendar.git --save</span><br></pre></td></tr></table></figure></li><li><p>下载<code>calendar.js</code>和<code>languages.js</code>文件，保存到<code>themes\Butterfly\source\js</code>目录</p><ul><li><a href="https://github.com/pengloo53/Hexo-theme-light_cn/blob/master/source/js/calendar.js" target="_blank" rel="noopener">calendar.js</a></li><li><a href="https://github.com/pengloo53/Hexo-theme-light_cn/blob/master/source/js/languages.js" target="_blank" rel="noopener">languages.js</a></li></ul></li><li><p>编辑calendar.js文件，在最后一行 <code>}(jQuery));</code> 的前面加上:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#calendar'</span>).aCalendar(<span class="string">'zh-CN'</span>);<span class="comment">//'zh-CN'请根据自己博客的语言选择</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>编辑<code>butterfly.yml</code>文件，插入script插件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel="stylesheet" href="xxxxx"&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src="xxxx"&gt;&lt;/script&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="/js/calendar.js"&gt;&lt;/script&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="/js/languages.js"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>下载<a href="https://raw.githubusercontent.com/pengloo53/Hexo-theme-light_cn/master/source/css/_partial/calendar.styl" target="_blank" rel="noopener">calendar.styl</a>，保存到<code>themes\Butterfly\source\css\ _layout</code>目录</p></li></ol><div class="note info">            <p>下载的<code>calendar.styl</code>文件样式有问题，可以根据自己的需要修改</p>          </div><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#calendar</span><br><span class="line">  a</span><br><span class="line">    <span class="attribute">text-decoration</span> none</span><br><span class="line"></span><br><span class="line">.cal-head</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">15px</span></span><br><span class="line">  <span class="attribute">position</span> relative</span><br><span class="line">  <span class="attribute">height</span> <span class="number">20px</span></span><br><span class="line">  <span class="attribute">padding</span> <span class="number">8px</span> <span class="number">6px</span> <span class="number">2px</span> <span class="number">6px</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-prev</span>,.cal-next</span><br><span class="line">  <span class="attribute">position</span> absolute</span><br><span class="line">  <span class="attribute">top</span> <span class="number">9px</span></span><br><span class="line">  <span class="attribute">width</span> <span class="number">16px</span></span><br><span class="line">  <span class="attribute">height</span> <span class="number">18px</span></span><br><span class="line">  <span class="attribute">padding</span> <span class="number">3px</span> <span class="number">4px</span></span><br><span class="line">  <span class="attribute">border</span> <span class="number">1px</span> solid transparent</span><br><span class="line">  <span class="attribute">color</span> <span class="number">#333</span></span><br><span class="line">  <span class="attribute">outline</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">.cal-prev</span><br><span class="line">  <span class="attribute">left</span> <span class="number">8px</span></span><br><span class="line">  &amp;:before</span><br><span class="line">  <span class="attribute">border-right</span> <span class="number">9px</span> solid <span class="number">#333</span></span><br><span class="line"></span><br><span class="line">.cal-next</span><br><span class="line">  <span class="attribute">right</span> <span class="number">8px</span></span><br><span class="line">  &amp;:before</span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">9px</span> solid <span class="number">#333</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-prev</span>:before,<span class="selector-class">.cal-next</span>:before</span><br><span class="line">  <span class="attribute">content</span> <span class="string">''</span></span><br><span class="line">  <span class="attribute">display</span> block</span><br><span class="line">  <span class="attribute">width</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">height</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">border-top</span> <span class="number">5px</span> solid transparent</span><br><span class="line">  <span class="attribute">border-bottom</span> <span class="number">5px</span> solid transparent</span><br><span class="line"></span><br><span class="line">.cal-title</span><br><span class="line">  <span class="attribute">width</span> <span class="number">120px</span></span><br><span class="line">  <span class="attribute">margin</span> <span class="number">0</span> auto</span><br><span class="line">  <span class="attribute">color</span> <span class="number">#333</span></span><br><span class="line">  <span class="attribute">font</span> bold <span class="number">14px</span>/<span class="number">18px</span> Arial</span><br><span class="line">  <span class="attribute">text-align</span> center</span><br><span class="line">  a</span><br><span class="line">    <span class="attribute">border</span> <span class="number">1px</span> solid transparent</span><br><span class="line">    <span class="attribute">color</span> <span class="number">#9f9f9f</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal</span>,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-class">.cal</span> td</span><br><span class="line">  <span class="attribute">border</span> <span class="number">1px</span> solid <span class="number">#d1d1d1</span></span><br><span class="line"></span><br><span class="line">.cal</span><br><span class="line">  <span class="attribute">display</span>: table</span><br><span class="line">  <span class="attribute">border-collapse</span> separate</span><br><span class="line">  <span class="attribute">border-spacing</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">border-width</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span></span><br><span class="line">  <span class="attribute">table-layout</span> fixed</span><br><span class="line">  <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">  <span class="attribute">margin</span> <span class="number">0</span></span><br><span class="line">  th</span><br><span class="line">    <span class="attribute">background</span> <span class="number">#9f9f9f</span></span><br><span class="line">    <span class="attribute">color</span> <span class="number">#fff</span></span><br><span class="line">    <span class="attribute">border-width</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">0</span></span><br><span class="line">    <span class="attribute">font-weight</span> <span class="number">700</span></span><br><span class="line">  td</span><br><span class="line">    <span class="attribute">border-width</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">0</span></span><br><span class="line">  tbody</span><br><span class="line">    a</span><br><span class="line">      <span class="attribute">background-color</span> <span class="number">#007acc</span></span><br><span class="line">      <span class="attribute">color</span> <span class="number">#fff</span></span><br><span class="line">      <span class="attribute">display</span> block</span><br><span class="line">      <span class="attribute">font-weight</span> <span class="number">700</span></span><br><span class="line">    .cal-today</span><br><span class="line">      <span class="attribute">background-color</span> <span class="number">#66ecfd</span></span><br><span class="line">      <span class="attribute">color</span> <span class="number">#fff</span></span><br><span class="line">  .cal-gray</span><br><span class="line">    <span class="attribute">color</span> <span class="number">#bbb8b8</span></span><br><span class="line"></span><br><span class="line">[data-theme=<span class="string">'dark'</span>] <span class="selector-class">.cal</span> .cal-gray</span><br><span class="line">  <span class="attribute">color</span> <span class="number">#505050</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-class">.cal</span> td</span><br><span class="line">  <span class="attribute">font-weight</span> normal</span><br><span class="line">  <span class="attribute">line-height</span> <span class="number">2.5625</span></span><br><span class="line">  <span class="attribute">padding</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">text-align</span> center</span><br><span class="line"></span><br><span class="line">[data-theme=<span class="string">'dark'</span>] <span class="selector-class">.cal</span> .cal-foot</span><br><span class="line">  <span class="attribute">color</span> <span class="number">#9f9f9f</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal</span> .cal-foot</span><br><span class="line">  <span class="attribute">color</span> <span class="number">#2ca6cb</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-title</span> <span class="selector-tag">a</span>:hover,</span><br><span class="line"><span class="selector-class">.cal-prev</span>:hover,</span><br><span class="line"><span class="selector-class">.cal-next</span>:hover,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-class">.cal-foot</span>:hover,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-class">.cal-foot</span>:focus,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">tbody</span> <span class="selector-tag">a</span>:hover,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">tbody</span> <span class="selector-tag">a</span>:focus</span><br><span class="line">  <span class="attribute">background-color</span> <span class="number">#686868</span></span><br><span class="line">  <span class="attribute">color</span> <span class="number">#fff</span></span><br><span class="line">  <span class="attribute">cursor</span> pointer</span><br></pre></td></tr></table></figure><ol start="6"><li>在<code>themes\Butterfly\layout\includes\widget</code> 文件夹新建 <code>card_calendar.pug</code> 文件，文件内容如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-calendar</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.far.fa-calendar-alt(aria-hidden&#x3D;&quot;true&quot;)</span><br><span class="line">      span&#x3D; _p(&#39;aside.card_calendar&#39;)</span><br><span class="line">    div.widget-wrap</span><br><span class="line">    div#calendar.widget</span><br></pre></td></tr></table></figure><ol start="7"><li>编辑 <code>themes\Butterfly\layout\includes\widget\index.pug</code> 文件，在你想要显示的位置插入以下代码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_calendar</span><br><span class="line">  include .&#x2F;card_calendar.pug</span><br></pre></td></tr></table></figure><ol start="8"><li>编辑<code>butterfly.yml</code>文件，在<code>card_webinfo</code>下面添加一行<code>card_calendar: true</code></li><li>编辑 <code>themes\Butterfly\languages\zh-CN.yml</code> 文件 (请根据你的网站语言选择)，找到 <code>card_announcement: 公告</code> , 在下面添加一行 <code>card_calendar: 文章日历</code> (后面的文本可自定义)</li><li>如果不想显示直接把<code>butterfly.yml</code>文件的<code>card_calendar: true</code>改为<code>card_calendar: false</code></li></ol><h3 id="文章持续更新ing"><a href="#文章持续更新ing" class="headerlink" title="文章持续更新ing"></a>文章持续更新ing</h3>]]></content>
      
      
      <categories>
          
          <category> hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly小修改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机第二章—JVM内存结构</title>
      <link href="/posts/e614237b.html"/>
      <url>/posts/e614237b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>程序在运行过程中会划分为不同区域，主要有下面七类：</p><ul><li><p>程序计数器</p></li><li><p>虚拟机栈</p></li><li><p>本地方法栈</p></li><li><p>堆</p></li><li><p>方法区</p></li><li><p>运行时常量池（包含于方法区）</p></li><li><p>直接内存</p><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>这里放一张JVM运行时的内存结构</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200413172422.png" alt="在这里插入图片描述"></p></li></ul><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器看成是<code>当前线程所执行字节码的行号指示器</code>，简单来讲就是通过改变计数器的值来选择下一条需要执行的字节码指令。</p><p>程序计数器控制指令的分支、循环、跳转、异常处理、线程恢复等。</p><p>程序计数器的内存区域属于<strong>线程私有</strong>，随着线程的存在而存在，消亡而消亡，而且不同线程之间的计数器互不影响。</p><h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200413162308.png" alt="img"></p><p>java虚拟机栈存在于，方法被执行的时候，会创建一个<code>帧栈</code>，描述的是方法执行的线程内存模型。</p><p>当调用一个新的方法时就向栈中压入一个新的帧栈；当方法执行完成后，帧栈从栈中被弹出。</p><p><strong>帧栈</strong>存储：局部变量表、操作数栈、动态连接、方法出口等信息。</p><p>局部变量表存放了编译期的各种<code>基本数据类型(boolean\byte\char\float\double...)</code>、<code>对象引用</code>(引用的形式是reference类型，可以是一个指向对象起始位置的指针或者是代表对象的句柄)、<code>returnAddress类型</code>(指向一条字节码指令的地址)</p><p><strong>局部变量表</strong>中的存储空间以  局部变量槽来表示，long、double类型长64位占两个变量槽。在编译时候就能计算出来，在运行时不发生改变。</p><p>java虚拟机栈也是属于<strong>线程私有</strong></p><p>当帧栈溢出 抛出 StackOverflowError异常，扩展到超过内存空间抛出 OutOfMemoryError</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈于前面类似，不同的是执行的是本地(Native)方法服务</p><p>本地方法是用其他方法写的(c、c++、汇编)，一般为基于本机硬件和操作系统的程序</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200413162345.png" alt="img"></p><h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>java堆是<strong>所有线程共享的一块内存区域</strong>，存放的是<code>对象实例</code></p><p>java堆是垃圾收集的主要内容之一，所以也被称为<code>GC堆</code>,它在物理上可以是不连续的，但逻辑上被视为连续的。</p><p>以前虚拟机将堆划分为<code>老年代、新生代、永久代、Eden、Survivor</code>，现在也有了新的发展可以不用分代，具体在垃圾回收机制方面查看。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区用于存放<strong>加载类的类信息、常量、静态变量、和即时编译器(jit)后的代码缓存等数据</strong></p><p>在JDK1.8之前，一直是将方法区划分为永久代，而在之后选择用<code>元空间(MetaSpace)</code> 来取代永久代的说法。方法区的回收目标主要是<strong>常量池和类的卸载</strong>，用永久代管理会产生一个问题：永久区是有大小限制的，如果有大量常量很容易导致OOM内存溢出。而且对类的卸载很困难。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200413170150.png" alt="img"></p><p>元空间存在于本地内存，是进程内存的一部分，摆脱了堆大小的限制。</p><p>为什么要在直接内存里拿出来一块内存作为元空间取代永久代呢？主要的说法有以下几个：</p><p>（1）类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p><p>（2）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p><p>即方便分配管理，因为直接内存空间比较充足；便于回收，因为永久代本来回收垃圾的事件发生概率很低，直接从JVM中拿出可以提高回收效率。</p><p>总结一下metaspace的好处：</p><ul><li>位置移到了堆外使用native memory, 取消了原来的大小限制</li><li>字符串常量和Class对象移动到了堆中管理</li><li>类和类加载器的生命周期一致，不需要单独回收某个类的空间, 当类加载器被回收时, 所属metaspace的内存一并回收</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池属于方法区的一部分，包括：<strong>编译期生成的各种字面量和符号引用</strong></p><p>这里讲一下java编译后的Class文件主要包含的内容有：类的版本、字段、方法、接口、常量池表。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存和JDK1.8后的元空间同属于本地内存，也称为<code>堆外内存</code></p><h4 id="操作直接内存"><a href="#操作直接内存" class="headerlink" title="操作直接内存"></a>操作直接内存</h4><p>在 NIO (New Input/Output)类中引入了一种基于通道和缓冲的 IO 方式。</p><p>它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>对象创建的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200422113458.jpg" alt></p><p>分配内存空间有两种方式：</p><ul><li>指针碰撞（堆内存规整）：Serial、ParNew等垃圾收集器</li><li>空闲列表（堆内存不规整）：CMS（基于标记-清除算法）</li></ul><p><strong>指针碰撞</strong>是指，java堆内存是绝对规整的，已被使用的内存和空闲的内存各占一部分，中间放着一个指针作为分界点，<strong>分配内存就是将指针向空闲内存空间方向移动一段与对象大小相等的距离</strong>。</p><p><strong>空闲列表</strong>是指，java堆内存不是绝对规整的，已被使用的内存和空闲内存交错在一起，虚拟机维护一个空闲列表，在分配时从列表找到一块可用内存给对象实例，并更新列表的记录。</p><p>Java堆是否规整是由所采用的垃圾收集器是否带有<code>空间压缩整理</code>的能力决定。</p><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>两个对象同时分配内存，可能出现线程安全的问题。解决方法有:</p><ul><li>分配内存空间时进行同步处理</li><li>给每个线程分配一个TLAB（本地线程分配缓冲区）</li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在堆内存中可划分为三个部分：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong></p><p><strong>对象头</strong>包括两部分：<strong>存储对象自身运行时数据</strong>(Hashcode,GC分代年龄,锁状态,持有锁,偏向线程ID,偏向时间戳等)，总长度为32bit/64bit ，被称为 <code>Mark Word</code></p><p>还有一部分<strong>类型指针</strong>，即对象指向它的类型元数据指针，通过这个指针来确定该对象是哪个类的实例</p><p><strong>实例数据</strong>存储的是在程序代码里面定义的各种类型字段，虚拟机分配顺序为<code>longs/doubles、ints、shorts/chars、bytes/booleans、oops</code></p><p><strong>对齐填充</strong>:占位符，只是为了保证对象大小是8字节的整数倍</p><h3 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式(?)"></a>对象的访问方式(?)</h3><ul><li>句柄访问</li><li>指针访问</li></ul><p>这里讲一下句柄访问，Java堆会划出一块内存作为句柄池，句柄中包含了指向<code>对象实例数据的指针</code>和<code>指向对象类型数据的指针</code></p><p>使用句柄的好处是reference中存储的是稳定的句柄指针，对象移动时<strong>只会改变句柄中实例数据的指针，reference本身不需要修改</strong></p><p>使用直接指针好处就是速度快，只使用一次定位，现在主流虚拟机主要使用直接指针方式访问</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200422110347.png" alt></p><p>参考资料：</p><ul><li>《深入理解Java虚拟机（第三版）》</li><li><a href="https://blog.csdn.net/m0_37407587/article/details/104971109" target="_blank" rel="noopener">CSDN博客——JVM的内存结构(一) 运行时数据区</a></li><li><a href="https://www.cnblogs.com/shen-qian/p/11277085.html" target="_blank" rel="noopener">JDK8的JVM内存结构，元空间替代永久代成为方法区及常量池的变化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE部分 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高级知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记第一次面试的凉经</title>
      <link href="/posts/9c11dd7b.html"/>
      <url>/posts/9c11dd7b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>2020.4.12 收到了字节跳动后台开发-教育部门的一面邀请，第一次面试,整个过程面试官人很nice，但是奈何我好多基础知识点都忘了😭，也就只面了30min左右..</strong></p><ol><li><p>上来自我介绍+项目(balabala)，做过秒杀项目，秒杀是怎么实现的？怎么解决高并发问题？（问到了是在业务层面的加锁还是数据库层面的加锁）</p><blockquote><p>比较简单的方法，在高并发情况，很多用户访问网页，评论网页，每一个请求都会更新数据库内的字段，由于每次请求会加锁，服务器很容易卡死。所以可以先将请求存入Redis中，过一段时间再写回数据库，类似’异步队列’，异步刷新网页对用户的体验影响较少。</p></blockquote></li><li><p>问到了新闻资讯项目里面redis点赞功能的实现(实现时用了几个队列，如何获取点赞用户信息，怎么存储…我忘了项目忘的快啊..)</p><blockquote><p>项目里面用Jedis里的<strong>set</strong>实现</p><p>写了一个RedisUtil类的方法：</p><ol><li>getLikeKey(int entityId,int entityType): 获取like对应redis的集合中的key</li><li>getDisLikeKey(int entityId,int entityType):获取dislike对应redis的集合中的key</li></ol><ul><li>点赞：’将当前用户的userid作为value’，存入对应Like集合中，判断disLike集合中是否有此id值，有的话移除；</li><li>点踩：与上面操作相反</li></ul></blockquote></li><li><p>TCP协议的特点</p><blockquote><p>面向连接的、字节流、可靠传输</p></blockquote></li><li><p>三次握手/四次挥手过程，三次握手过程中客户端和服务端状态的变化，只有两次握手会产生的问题</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200412205631.png" alt="image-20200412205449062"></p><blockquote><p>三次握手服务器客户端的状态：</p><p><strong>第一次握手：</strong>客户端发送syn包(syn=x)到服务器，并进入<code>SYN_SEND</code>状态，等待服务器确认</p><p><strong>第二次握手：</strong>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个syn包（syn=y），即SYN+ACK包，此时服务器进入<code>SYN_RECV</code>状态</p><p><strong>第三次握手：</strong>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入<code>ESTABLISHED</code>状态</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200412201507.jpg" alt="img"></p><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p></li><li><p>TCP协议如何保证可靠传输？</p><p><strong>序列号/确认应答、超时重传、最大消息长度、滑动窗口控制、拥塞控制</strong></p></li><li><p>进程和线程的区别</p><blockquote><p>I 拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>II 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>III 系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>IV 通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p></blockquote></li><li><p>线程通信机制</p><blockquote><ol><li><p>使用volatile关键字</p><p>基于 <strong><em>volatile</em></strong> 关键字来实现线程间相互通信是使用共享内存的思想，大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式</p></li><li><p>使用Object类的wait和notify/notifyAll方法</p><p>wait和 notify必须配合synchronized使用，wait方法释放锁，notify方法不释放锁</p></li><li><p>使用JUC工具类 CountDownLatch</p><p>jdk1.5之后在java.util.concurrent包下提供了很多并发编程相关的工具类，简化了我们的并发编程代码的书写，<strong><em>CountDownLatch</em></strong>基于AQS框架，相当于也是维护了一个线程间共享变量state</p></li><li><p>使用ReentrantLock结合Condition</p></li><li><p>使用基本LockSupport实现线程间的阻塞和唤醒</p></li></ol></blockquote></li><li><p>MySQL <strong>ACID机制</strong></p><p><strong>A-原子性（Atomicity）</strong></p><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><p><strong>C-一致性（Consistency）</strong></p><p>事务前后数据的完整性必须保持一致。</p><p><strong>I-隔离性（Isolation）</strong></p><p>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p><p><strong>D-持久性（Durability）</strong></p><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p></li><li><p>编程题：经典题——<strong>股票问题</strong>（k=1只能进行一次买卖），很久以前做过的了，然后又是忘了，还和人家掰扯了半天😰</p></li></ol><p>最后聊了聊现在的状况，还没收到hr回复，自我感觉就已经凉凉了，最近复习这些知识点的时候看到过，都是基础问题，然后我看完就忘了。。。希望巩固巩固知识吧，现在才研一，提高提高复习效率是关键✔</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二种排序总结(快排、归并、希尔、计数排序等)</title>
      <link href="/posts/fdbc79f7.html"/>
      <url>/posts/fdbc79f7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>排序算法在计算机科学入门课程中很普遍，在学习排序算法的时候，涉及到大量的各种核心算法概念，例如大O表示法，分治法，堆和二叉树之类的数据结构，随机算法，最佳、最差和平均情况分析，时空权衡以及上限和下限，本文就介绍了十二种排序算法供大家学习。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>排序算法是用来根据元素对应的比较运算符重新排列给定的数组的算法，输出的数组是一个根据比较符从小到大或者从大到小依次排列的数组。比较运算符是用于确定相应数据结构中元素的新顺序，比如在整数数组里面，对应的比较符号就是大于或者小于号，用户也可以自己定义对应的比较运算符。</p><p>比如如果输入是[4,2,3,1]，按照从小到大输出，结果应该是<code>[1,2,3,4]</code></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><p>如果在数组中有两个元素是相等的，在经过某个排序算法之后，原来在前面的的那个元素仍然在另一个元素的前面，那么我们就说这个排序算法是稳定的。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331135617.jpg" alt="stable sort"></p><p>如果在排序之后，原来的两个相等元素中在前面的一个元素被移到了后面，那么这个算法就是不稳定的。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331135648.jpg" alt="unstable sort"></p><p>比如排序之前数组为<code>[3(a),2,3(b)]</code>（其中<code>a</code>和<code>b</code>分别代表两个不同的<code>3</code>），经过某个排序算法之后是<code>[2,3(a),3(b)]</code>，那么这个算法就是稳定的；如果变成了<code>[2,3(b),3(a)]</code>，那么这个算法是不稳定的。</p><p>再比如在按照身高排队去食堂打饭的过程中，小明和小刚的身高都是170，原来小明在小刚前面，但是经过排序之后小明发现小刚到了他前面了，这样小明肯定对这个不稳定的排序有意见。</p><h5 id="比较排序、非比较排序"><a href="#比较排序、非比较排序" class="headerlink" title="比较排序、非比较排序"></a>比较排序、非比较排序</h5><p>如果一个算法需要在排序的过程中使用比较操作来判断两个元素的大小关系，那么这个排序算法就是<strong>比较排序</strong>，大部分排序算法都是比较排序，比如冒泡排序、插入排序、堆排序等等，这种排序算法的平均时间复杂度最快也只能是O(nlogn)。</p><p><strong>非比较排序</strong>比较典型的有计数排序、桶排序和基数排序，这类排序能够脱离比较排序时间复杂度的束缚，达到O(n)级别的效率。</p><h3 id="十二种排序算法"><a href="#十二种排序算法" class="headerlink" title="十二种排序算法"></a>十二种排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序是从左到右依次比较相邻的两个元素，如果前一个元素比较大，就把前一个元素和后一个交换位置，遍历数组之后保证最后一个元素相对于前面的永远是最大的。然后让最后一个保持不变，重新遍历前<code>n-1</code>个元素，保证第<code>n-1</code>个元素在前<code>n-1</code>个元素里面是最大的。依此规律直到第<code>2</code>个元素是前<code>2</code>个元素里面最大的，排序就结束了。</p><p>因为这个排序的过程很像冒泡泡，找到最大的元素不停的移动到最后端，所以这个排序算法就叫冒泡排序。<br><img src="/SkironYong.github.io/posts/fdbc79f7.htm/E:%5CTypora%5CTypora%5CNotes%5CLeetCode%5C%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%5C%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%5C20200331140713.gif" alt><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">// 冒泡得到n-1个最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j-<span class="number">1</span>]&gt;nums[j])</span><br><span class="line">                swap(nums, j, j-<span class="number">1</span>);           <span class="comment">// 交换得到较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的最大特点就是代码简单，短短的五行代码就能完成整个排序的操作。</p><p>时间复杂度比较稳定不管怎样都需要O(n^2^)次比较，所以是O(n^2^)的时间复杂度。</p><p>空间复杂度是O(1)，所有操作在原来的数组完成就可以了，不需要额外的空间。</p><p>算法是稳定的，在冒泡的过程中如果两个元素相等，那么他们的位置是不会交换的。</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序的思路比较简单，先找到前<code>n</code>个元素中最大的值，然后和最后一个元素交换，这样保证最后一个元素一定是最大的，然后找到前<code>n-1</code>个元素中的最大值，和第<code>n-1</code>个元素进行交换，然后找到前<code>n-2</code>个元素中最大值，和第<code>n-2</code>个元素交换，依次类推到第2个元素，这样就得到了最后的排序数组。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331141200.gif" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;         <span class="comment">// 最大元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[maxIndex]&lt;nums[j]) &#123;</span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, maxIndex, i);   <span class="comment">// 把这个最大的元素移到最后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度和冒泡排序一样比较稳定，都需要O(n^2^)次比较，所以时间复杂度是O(n^2^)</p><p>空间复杂度是O(1)，不需要额外空间，是原地算法。</p><p>选择排序最简单的版本是不稳定的，比如数组<code>[1,3,2,2]</code>，表示为<code>[1,3,2(a),2(b)]</code>，在经过一轮遍历之后变成了<code>[1,2(b),2(a),3]</code>，两个<code>2</code>之间的顺序因为第一个<code>2</code>和<code>3</code>的调换而颠倒了，所以不是稳定排序。</p><p>不过可以改进一下选择排序变成稳定的。原来不稳定是因为交换位置导致的，现在如果改成<strong>插入操作</strong>（不是使用数组而是链表，把最大的元素插入到最后）的话，就能变成稳定排序。比如<code>[1,3,2(a),2(b)]</code>，在第一轮中变成了<code>[1,2(a),2(b),3]</code>，这样就能够保持相对位置，变成稳定排序。</p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序的核心思想是遍历整个数组，保持当前元素左侧始终是排序后的数组，然后将当前元素插入到前面排序完成的数组的对应的位置，使其保持排序状态。有点动态规划的感觉，类似于先把前<code>i-1</code>个元素排序完成，再插入第<code>i</code>个元素，构成<code>i</code>个元素的有序数组。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331141550.gif" alt="insertion sort"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;   <span class="comment">// 从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;nums[j]&lt;nums[j-<span class="number">1</span>]) &#123;     <span class="comment">// 将当前元素移动到合适的位置</span></span><br><span class="line">            swap(nums, j, j-<span class="number">1</span>);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度上，插入排序在最好的情况，也就是数组已经排好序的时候，复杂度是O(n)，在其他情况下都是O(n2)。</p><p>空间复杂度是O(1)，不需要额外的空间，是原地算法。</p><p>插入排序是稳定排序，每次交换都是相邻元素的交换，不会有选择排序的那种跳跃式交换元素。</p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序可以看作是一个冒泡排序或者插入排序的变形。希尔排序在每次的排序的时候都把数组拆分成若干个序列，一个序列的相邻的元素索引相隔的固定的距离<code>gap</code>，每一轮对这些序列进行冒泡或者插入排序，然后再缩小<code>gap</code>得到新的序列一一排序，直到<code>gap</code>为0</p><p>比如对于数组<code>[5,2,4,3,1,2]</code>，第一轮<code>gap=3</code>拆分成<code>[5,3]</code>、<code>[2,1]</code>和<code>[4,2]</code>三个数组进行插入排序得到<code>[3,1,2,5,2,4]</code>；第二轮<code>gap=1</code>，拆分成<code>[3,2,2]</code>和<code>[1,5,4]</code>进行插入排序得到<code>[2,1,2,4,3,5]</code>；最后<code>gap=0</code>，全局插入排序得到<code>[1,2,2,3,4,5]</code></p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142016.gif" alt="shell sort"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shellSor2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = nums.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gap; i++) &#123;                        <span class="comment">// 对每个子序列进行排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+gap; j &lt; nums.length; j+=gap) &#123;     <span class="comment">// 插入排序的部分</span></span><br><span class="line">                <span class="keyword">int</span> temp = j;</span><br><span class="line">                <span class="keyword">while</span> (temp &gt; i &amp;&amp; nums[temp] &lt; nums[temp-gap]) &#123;</span><br><span class="line">                    swap(nums, temp, temp-gap);</span><br><span class="line">                    temp -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Donald Shell于1959年发布了这种排序算法，运行时间在很大程度上取决于它使用的间隔，在实际使用中，其时间复杂度仍然是一个悬而未决的问题，基本在O(n^2^)和O(n^4/3^)之间。</p><p>空间复杂度是O(1)，是原地算法。</p><p>这个算法是不稳定的，里面有很多不相邻元素的交换操作。</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序是典型的使用<strong>分治思想</strong>（divide-and-conquer）解决问题的案例。在排序的过程中，把原来的数组变成左右两个数组，然后分别进行排序，当左右的子数组排序完毕之后，再合并这两个子数组形成一个新的排序数组。整个过程递归进行，当只剩下一个元素或者没有元素的时候就直接返回。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142138.gif" alt="merge sort"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;  <span class="comment">// 需要左右边界确定排序范围</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    mergeSort(nums, left, mid);                           <span class="comment">// 先对左右子数组进行排序</span></span><br><span class="line">    mergeSort(nums, mid+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];                   <span class="comment">// 临时数组存放合并结果</span></span><br><span class="line">    <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=right) &#123;                            <span class="comment">// 开始合并数组</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;=nums[j]) temp[cur] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[cur] = nums[j++];</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid) temp[cur++] = nums[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=right) temp[cur++] = nums[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k++) &#123;             <span class="comment">// 合并数组完成，拷贝到原来的数组中</span></span><br><span class="line">        nums[left+k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度上归并排序能够稳定在O(nlogn)的水平，在每一级的合并排序数组过程中总的操作次数是n，总的层级数是logn，相乘得到最后的结果就是O(nlogn)</p><p>空间复杂度是O(n)，因为在合并的过程中需要使用临时数组来存放临时排序结果。</p><p>归并排序是稳定排序，保证原来相同的元素能够保持相对的位置。</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>其核心的思路是取第一个元素（或者最后一个元素）作为分界点，把整个数组分成左右两侧，左边的元素小于或者等于分界点元素，而右边的元素大于分界点元素，然后把分界点移到中间位置，对左右子数组分别进行递归，最后就能得到一个排序完成的数组。当子数组只有一个或者没有元素的时候就结束这个递归过程。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142635.gif" alt="quick sort"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = left+<span class="number">1</span>;               <span class="comment">// 小于分界点元素的最右侧的指针</span></span><br><span class="line">    <span class="keyword">int</span> hi = right;                <span class="comment">// 大于分界点元素的最左侧的指针</span></span><br><span class="line">    <span class="keyword">while</span> (lo&lt;=hi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[lo]&gt;nums[left]) &#123; <span class="comment">// 交换元素确保左侧指针指向元素小于分界点元素</span></span><br><span class="line">            swap(nums, lo, hi);</span><br><span class="line">            hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lo--;                          <span class="comment">// 回到小于分界点元素数组的最右侧</span></span><br><span class="line">    swap(nums, left, lo);          <span class="comment">// 将分界点元素移到左侧数组最右侧</span></span><br><span class="line">    quickSort2(nums, left, lo-<span class="number">1</span>);</span><br><span class="line">    quickSort2(nums, lo+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我自己还有另一种快排写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> [] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> pivot=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">         pivot=partition(arr,left,right);</span><br><span class="line">         quickSort(arr,left,pivot-<span class="number">1</span>);</span><br><span class="line">         quickSort(arr,pivot+<span class="number">1</span>,right);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> key=arr[left];</span><br><span class="line">      <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">         <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;=key) &#123;</span><br><span class="line">            right--;</span><br><span class="line">         &#125;</span><br><span class="line">         arr[left]=arr[right];</span><br><span class="line">         <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;=key) &#123;</span><br><span class="line">            left++;</span><br><span class="line">         &#125;</span><br><span class="line">         arr[right]=arr[left];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[left]=key;</span><br><span class="line">      <span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure><p>时间复杂度在最佳情况是O(nlogn)，但是如果分界点元素选择不当可能会恶化到O(n^2^)，但是这种情况比较少见（比如数组完全逆序），如果随机选择分界点的话，时间复杂度能够稳定在O(nlogn)。另外如果元素中相同元素数量比较多的话，也会降低排序性能。</p><p>空间复杂度在O(logn)水平，属于堆栈调用，在最坏的情况下空间复杂度还是O(n)，平均情况下复杂度是O(logn)</p><p>快速排序是不稳定的，因为包含跳跃式交换元素位置。</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是一个效率要高得多的选择排序，首先把整个数组变成一个最大堆，然后每次从堆顶取出最大的元素，这样依次取出的最大元素就形成了一个排序的数组。堆排序的核心分成两个部分，第一个是新建一个堆，第二个是弹出堆顶元素后重建堆。</p><p>新建堆不需要额外的空间，而是使用原来的数组，一个数组在另一个维度上可以当作一个完全二叉树（除了最后一层之外其他的每一层都被完全填充，并且所有的节点都向左对齐），对于下标为<code>i</code>的元素，他的子节点是<code>2*i+1</code>和<code>2*i+2</code>（前提是没有超出边界）。在新建堆的时候从左向右开始遍历，当遍历到一个元素的时候，重新排列从这个元素节点到根节点的所有元素，保证满足最大堆的要求（父节点比子节点要大）。遍历完整个数组的时候，这个最大堆就完成了。</p><p>在弹出根节点之后（把根节点的元素和树的最底层最右侧的元素互换），堆被破坏，需要重建。从根节点开始和两个子节点比较，如果父节点比最大的子节点小，那么就互换父节点和最大的子节点，然后把互换后在子节点位置的父节点当作新的父节点，和它的子节点比较，如此往复直到最后一层，这样最大堆就重建完毕了。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331143454.gif" alt="heap sort"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    heapify(nums);                                 <span class="comment">// 新建一个最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, i);                       <span class="comment">// 弹出最大堆的堆顶放在最后</span></span><br><span class="line">        rebuildHeap(nums, <span class="number">0</span>,i-<span class="number">1</span>);          <span class="comment">// 重建最大堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> par = (i-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;                       <span class="comment">// 找到父节点</span></span><br><span class="line">        <span class="keyword">int</span> child = i;                            <span class="comment">// 定义子节点</span></span><br><span class="line">        <span class="keyword">while</span> (child&gt;<span class="number">0</span>&amp;&amp;nums[par]&lt;nums[child]) &#123;  <span class="comment">// 从子节点到根节点构建最大堆</span></span><br><span class="line">            swap(nums, par, child);</span><br><span class="line">            child = par;</span><br><span class="line">            par = (par-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebuildHeap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> par, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span>*par+<span class="number">1</span>;                           <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span>*par+<span class="number">2</span>;                          <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right&lt;=last &amp;&amp; nums[right]&gt;nums[left]) &#123;  <span class="comment">// 找到最大子节点</span></span><br><span class="line">        maxIndex = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left&lt;=last &amp;&amp; nums[par] &lt; nums[maxIndex]) &#123;<span class="comment">// 和最大子节点比较</span></span><br><span class="line">        swap(nums, par, maxIndex);                 <span class="comment">// 互换到最大子节点</span></span><br><span class="line">        rebuildHeap(nums, maxIndex, last);         <span class="comment">// 重建最大子节点代表的子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度稳定在O(nlogn)，因为在构建堆的时候时间遍历数组对于每个元素需要进行O(logn)次比较，时间复杂度是O(nlogn)。在弹出每个元素重建堆需要O(logn)的复杂度，时间复杂度也是O(nlogn)，所以整体的时间复杂度是O(nlogn)</p><p>空间复杂度是O(1)，在原数组进行所有操作就可以了。</p><p>堆排序是不稳定，堆得构建和重建的过程都会打乱元素的相对位置。</p><h4 id="二叉搜索树排序"><a href="#二叉搜索树排序" class="headerlink" title="二叉搜索树排序"></a>二叉搜索树排序</h4><p>二叉树搜索排序用数组内的所有元素构建一个搜索二叉树，然后用中序遍历重新将所有的元素填充回原来的数组中。因为搜索二叉树不能用数组来表示，所以必须使用额外的数据结构来构建二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331144034.gif" alt="binary search tree sort"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] bstSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[<span class="number">0</span>]);   <span class="comment">// 构建根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;  <span class="comment">// 将所有的元素插入到二叉搜索树中</span></span><br><span class="line">        buildTree(root, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    inorderTraversal(root, nums, <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>]);<span class="comment">// 中序遍历获取二叉树中的所有节点</span></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode node, <span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorderTraversal(node.left, nums, pos);</span><br><span class="line">    nums[pos[<span class="number">0</span>]++] = node.val;</span><br><span class="line">    inorderTraversal(node.right, nums, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(TreeNode node, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= node.val) &#123;                   <span class="comment">// 插入到右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buildTree(node.right, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                 <span class="comment">// 插入到左子树中</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buildTree(node.left, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;   <span class="comment">// 树节点的数据结构</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度上面根据原数组变化比较大，最差情况是整个数组是已经排好序的，这样二叉树会变成一个链表结构，时间复杂度退化到了O(n^2^)，但是最优和平均情况下时间复杂度在O(nlogn)水平。</p><p>空间复杂度是O(n)，因为要构建一个包含<code>n</code>个元素的二叉搜索树。</p><p>这个算法是稳定，在构建二叉树的过程中能够保证元素顺序的一致性。</p><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序是一个最基本的非比较排序，能够将时间复杂度提高到O(n)的水平，但是使用上比较有局限性，通常只能应用在键的变化范围比较小的情况下，如果键的变化范围特别大，建议使用基数排序。</p><p>计数排序的过程是创建一个长度为数组中最小和最大元素之差的数组，分别对应数组中的每个元素，然后用这个新的数组来统计每个元素出现的频率，然后遍历新的数组，根据每个元素出现的频率把元素放回到老的数组中，得到已经排好序的数组。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331144204.gif" alt="count sort"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;            <span class="comment">// 找到最大最小值</span></span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>]; <span class="comment">// 建立新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;            <span class="comment">// 统计每个元素出现频率</span></span><br><span class="line">        count[num-min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;  <span class="comment">// 根据出现频率把计数数组中的元素放回到旧数组中</span></span><br><span class="line">        <span class="keyword">while</span> (count[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            nums[cur++] = i+min;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计数排序能够将时间复杂度降低到O(n+r)（r为数组元素变化范围），不过这是对于数组元素的变化范围不是特别大。随着范围的变大，计数排序的性能就会逐渐降低。</p><p>空间复杂度为O(n+r)，随着数组元素变化范围的增大，空间复杂度也会变大。</p><p>计数排序是稳定的，原来排在前面的相同在计数的时候，仍然是排在每个计数位置的前面，在最后复原的时候也是从每个计数位的前面开始复原，所以最后相对位置还是相同的。</p><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>桶排序是将所有的元素分布到一系列的区间（也可以称之为<strong>桶</strong>）里面，然后对每个桶里面的所有元素分别进行排序的算法。</p><p>首先新建一个桶的数组，每个桶的规则需要提前制定好，比如元素在0~9为一个桶、10-19为一个桶。然后遍历整个待排序的数组，把元素分配到对应的桶里面。接下来单独对每个桶里面的元素进行排序，排序算法可以选择比较排序或者非比较排序，得到排序后的数组。最后把所有的桶内的元素还原到原数组里面得到最后的排序数组。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331144349.gif" alt="bucket sort"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> INTERVAL = <span class="number">100</span>;               <span class="comment">// 定义桶的大小</span></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;            <span class="comment">// 找到数组元素的范围</span></span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = (max - min + <span class="number">1</span>);      <span class="comment">// 计算出桶的数量</span></span><br><span class="line">    <span class="keyword">int</span> bucketSize = (count % INTERVAL == <span class="number">0</span>) ?( count / INTERVAL) : (count / INTERVAL+<span class="number">1</span>);</span><br><span class="line">    List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> List[bucketSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;            <span class="comment">// 把所有元素放入对应的桶里面</span></span><br><span class="line">        <span class="keyword">int</span> quotient = (num-min) / INTERVAL;</span><br><span class="line">        <span class="keyword">if</span> (buckets[quotient] == <span class="keyword">null</span>) buckets[quotient] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        buckets[quotient].add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bucket.sort(<span class="keyword">null</span>);       <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">            <span class="keyword">for</span> (Integer integer : bucket) &#123;  <span class="comment">// 还原桶里面的元素到原数组</span></span><br><span class="line">                nums[cur++] = integer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n+r)，空间复杂度O（n+r）稳定</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>假设当前数组的所有元素都是正数，桶的数量就固定在了10个，然后计算出最大元素的位数。首先根据每个元素的最低位进行分组，比如<code>1</code>就放入<code>1</code>这个桶，<code>13</code>就放入<code>3</code>这个桶，<code>111</code>也放入<code>1</code>这个桶，然后把所有的数字根据桶的顺序取出来，依次还原到原数组里面。在第二轮从第二位开始分组，比如<code>1</code>（看作<code>01</code>）放入<code>0</code>这个桶，<code>13</code>放入<code>1</code>这个桶，<code>111</code>也放入<code>1</code>这个桶，再把所有的元素从桶里面依次取出放入原数组。经过最大元素位数次的这样的操作之后，还原得到的数组就是一个已经排好序的数组</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331144658.gif" alt="radix sort"></p><p>考虑到数组里面还有负数的情况，可以把桶的大小扩大到19个，分别代表对应位在-9~9之间的数字，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;         <span class="comment">// 计算最大最小值</span></span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, -min);     <span class="comment">// 求得绝对值最大的值</span></span><br><span class="line">    <span class="keyword">int</span> digits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;              <span class="comment">// 计算绝对值最大的值的位数</span></span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        digits++;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> List[<span class="number">19</span>]; <span class="comment">// 建一个包含所有位数的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, mod = <span class="number">1</span>; i &lt; digits; i++, mod*=<span class="number">10</span>) &#123; <span class="comment">// 对十进制每一位进行基数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;                 <span class="comment">// 扫描数组将值放入对应的桶</span></span><br><span class="line">            pos = (num / mod) % <span class="number">10</span>;</span><br><span class="line">            buckets[pos+<span class="number">9</span>].add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123; <span class="comment">// 将桶内元素放回到数组里面</span></span><br><span class="line">            <span class="keyword">if</span> (bucket!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : bucket) &#123;</span><br><span class="line">                    nums[cur++] = integer;</span><br><span class="line">                &#125;</span><br><span class="line">                bucket.clear();                <span class="comment">// 将桶清空</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h4><p>Timsort是由Tim Peters在2002年实现的，自Python 2.3以来，它一直是Python的标准排序算法。Java在JDK中使用Timsort对非基本类型进行排序。Android平台和GNU Octave还将其用作默认排序算法。</p><p>Timsort是一种稳定的混合排序算法，同时应用了二分插入排序和归并排序的思想，在时间上击败了其他所有排序算法。它在最坏情况下的时间复杂度为O(nlogn)优于快速排序；最佳情况的时间复杂度为O(n)，优于归并排序和堆排序。</p><p>由于使用了归并排序，使用额外的空间保存数据，TimSort空间复杂度是O(n)</p><p><strong>Collection.sort()</strong>用到的算法就是TimSort算法</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th align="center"><strong>排序算法</strong></th><th align="center"><strong>最好情况</strong></th><th align="center"><strong>平均情况</strong></th><th align="center"><strong>最差情况</strong></th><th align="center"><strong>空间复杂度</strong></th><th align="center"><strong>稳定性</strong></th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">n^2^</td><td align="center">n^2^</td><td align="center">n^2^</td><td align="center">1</td><td align="center">✓</td></tr><tr><td align="center">选择排序</td><td align="center">n^2^</td><td align="center">n^2^</td><td align="center">n^2^</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">插入排序</td><td align="center">n</td><td align="center">n^2^</td><td align="center">n^2^</td><td align="center">1</td><td align="center">✓</td></tr><tr><td align="center">希尔排序</td><td align="center">nlogn</td><td align="center">nlogn</td><td align="center">n^4/3^</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">二叉树排序</td><td align="center">nlogn</td><td align="center">nlogn</td><td align="center">n^2^</td><td align="center">n</td><td align="center">✓</td></tr><tr><td align="center">归并排序</td><td align="center">nlogn</td><td align="center">nlogn</td><td align="center">nlogn</td><td align="center">n</td><td align="center">✓</td></tr><tr><td align="center">快速排序</td><td align="center">nlogn</td><td align="center">nlogn</td><td align="center">n^2^</td><td align="center">logn</td><td align="center"></td></tr><tr><td align="center">堆排序</td><td align="center">nlogn</td><td align="center">nlogn</td><td align="center">nlogn</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">计数排序</td><td align="center">-</td><td align="center">n+r</td><td align="center">n+r</td><td align="center">n+r</td><td align="center">✓</td></tr><tr><td align="center">桶排序</td><td align="center">-</td><td align="center">n+r</td><td align="center">n+r</td><td align="center">n+r</td><td align="center">✓</td></tr><tr><td align="center">基数排序</td><td align="center">-</td><td align="center">nk/d</td><td align="center">nk/d</td><td align="center">n+2^d^</td><td align="center">✓</td></tr><tr><td align="center">TimSort</td><td align="center">n</td><td align="center">nlogn</td><td align="center">nlogn</td><td align="center">n</td><td align="center">✓</td></tr></tbody></table><p>备注：r为排序数字的范围，d是数字总位数，k是数字总个数</p><h4 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h4><blockquote><p>作者：悟Space</p><p>转载链接：<a href="http://sunshuyi.vip/2020/03/15/leetcode/leetcode-sort/" target="_blank" rel="noopener">http://sunshuyi.vip/2020/03/15/leetcode/leetcode-sort/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 365水壶问题</title>
      <link href="/posts/82bc5cec.html"/>
      <url>/posts/82bc5cec.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><blockquote><p>输入: x = 3, y = 5, z = 4<br>输出: True</p></blockquote><h4 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h4><blockquote><p>输入: x = 2, y = 6, z = 5<br>输出: False</p></blockquote><h1 id="方法一-BFS广度优先树"><a href="#方法一-BFS广度优先树" class="headerlink" title="方法一 BFS广度优先树"></a>方法一 BFS广度优先树</h1><p>为什么想到用BFS？这种游戏的问题是很难穷尽所有可能的情况，过程中有很多的<font color="red">“状态”</font>,所以要用到[<strong>搜索算法</strong>]<br>[<strong>搜索算法</strong>]一般是在<strong>树</strong>或者<strong>图</strong>的结构进行【<strong>深度优先遍历</strong>】或者【<strong>广度优先遍历</strong>】，在「树」上的「深度优先遍历」就是「回溯算法」，在「图」上的「深度优先遍历」是「flood fill」 算法，深搜比较节约空间。这里我们用广度搜索更快找到符合状态。</p><p><font color="red">“状态”</font>，我们可以定义两个水壶A,B ,(a,b)表示当前状态。</p><p>状态总共有8种，分别定义以下的操作：  </p><p>装满任意一个水壶，定义为「操作一」，分为：<br>（1）装满 A，包括 A 为空和 A 非空的时候把 A 倒满的情况；<br>（2）装满 B，包括 B 为空和 B 非空的时候把 B 倒满的情况。</p><p>清空任意一个水壶，定义为「操作二」，分为<br>（1）清空 A；<br>（2）清空 B。</p><p>从一个水壶向另外一个水壶倒水，直到装满或者倒空，定义为「操作三」，其实根据描述「装满」或者「倒空」就知道可以分为 4 种情况：</p><p>（1）从 A 到 B，使得 B 满，A 还有剩；<br>（2）从 A 到 B，此时 A 的水太少，A 倒尽，B 没有满；<br>（3）从 B 到 A，使得 A 满，B 还有剩余；<br>（4）从 B 到 A，此时 B 的水太少，B 倒尽，A 没有满。</p><p>我们再讲一下<strong>BFS</strong>的思路：<br>我们需要用一个队列queue来保存搜索结点，一个set或者数组保存已经访问过的点：  </p><ol><li>初始时，队列和set均为空。将起始点放入队列及set。</li><li>如果队列为空则 bfs 结束。</li><li>弹出队首元素并访问其周围元素，设为 p。</li><li>如果p为目标状态则 bfs 结束。</li><li>访问 p 周围的元素，将不在set中的元素放入队列及set。跳转第 2 步。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x + y &lt; z) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        State initState = <span class="keyword">new</span> State(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queue存储广度优先队列</span></span><br><span class="line">        Queue&lt;State&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//set存储访问过的结点</span></span><br><span class="line">        Set&lt;State&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(initState);</span><br><span class="line">        visited.add(initState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            State p = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> curX = p.getX();</span><br><span class="line">            <span class="keyword">int</span> curY = p.getY();</span><br><span class="line">            <span class="keyword">if</span> (curX == z || curY == z || curX + curY == z) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;State&gt; nextStates = getNextStates(curX,curY,x,y);</span><br><span class="line">            <span class="comment">//将不在set中的元素放入队列和set</span></span><br><span class="line">            <span class="keyword">for</span>(State q: nextStates) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(q)) &#123;</span><br><span class="line">                    queue.offer(q);</span><br><span class="line">                    visited.add(q);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;State&gt; <span class="title">getNextStates</span><span class="params">(<span class="keyword">int</span> curX, <span class="keyword">int</span> curY, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最多8种状态</span></span><br><span class="line">        List&lt;State&gt; nextStates = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加满A</span></span><br><span class="line">        State nextState1 = <span class="keyword">new</span> State(x, curY);</span><br><span class="line">        <span class="comment">//加满B</span></span><br><span class="line">        State nextState2 = <span class="keyword">new</span> State(curX, y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空A</span></span><br><span class="line">        State nextState3 = <span class="keyword">new</span> State(<span class="number">0</span>, curY);</span><br><span class="line">        <span class="comment">//清空B</span></span><br><span class="line">        State nextState4 = <span class="keyword">new</span> State(curX, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以下4个分别对应从A-&gt;B和B-&gt;A的四种状态</span></span><br><span class="line">        <span class="comment">//A-&gt;B B满，A剩余</span></span><br><span class="line">        State nextState5 = <span class="keyword">new</span> State(curX - (y - curY), y);</span><br><span class="line">        <span class="comment">//A-&gt;B B没满，A空，A的水太少</span></span><br><span class="line">        State nextState6 = <span class="keyword">new</span> State(<span class="number">0</span>, curY + curX);</span><br><span class="line">        <span class="comment">//B-&gt;A A满，B剩余</span></span><br><span class="line">        State nextState7 = <span class="keyword">new</span> State(x, curY - (x - curX));</span><br><span class="line">        <span class="comment">//B-&gt;A A没满，B空，B的水太少</span></span><br><span class="line">        State nextState8 = <span class="keyword">new</span> State(curX + curY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态1，2 没有满的时候才需要加水</span></span><br><span class="line">        <span class="keyword">if</span> (curX &lt; x) &#123;</span><br><span class="line">            nextStates.add(nextState1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curY &lt; y) &#123;</span><br><span class="line">            nextStates.add(nextState2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//状态3，4 有水的时候才倒掉</span></span><br><span class="line">        <span class="keyword">if</span> (curX &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextStates.add(nextState3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextStates.add(nextState4);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//状态5,7 有剩余才倒</span></span><br><span class="line">        <span class="keyword">if</span> (curX - (y - curY) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextStates.add(nextState5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curY - (x - curX) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextStates.add(nextState7);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//状态6，8 倒过去倒不满才倒</span></span><br><span class="line">        <span class="keyword">if</span> (curX + curY &lt; y) &#123;</span><br><span class="line">            nextStates.add(nextState6);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curX + curY &lt; x) &#123;</span><br><span class="line">            nextStates.add(nextState8);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextStates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"State&#123;"</span> +</span><br><span class="line">                    <span class="string">"x="</span> + x +</span><br><span class="line">                    <span class="string">", y="</span> + y +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            State state = (State) o;</span><br><span class="line">            <span class="keyword">return</span> x == state.x &amp;&amp;</span><br><span class="line">                    y == state.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="方法二：数学方法（太强了）"><a href="#方法二：数学方法（太强了）" class="headerlink" title="方法二：数学方法（太强了）"></a>方法二：数学方法（太强了）</h1><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>首先，从两个水壶里的整体水量来看，每次操作，可分为下列情况：</p><ol><li>往空壶里加满水，总量加 x | y  </li><li>倒掉一壶水（满），总量减 x | y  </li><li>倒掉一壶水（不满），总量变成 x | y | 0</li><li>往不满的壶里加水，总量变为 x | y | x+y</li><li>从一个壶往另一个壶里倒水，总量不变 </li></ol><p>所以两个壶里水的总量一定是ax+by（a,b为整数），立即推，当z=ax+by时，返回true  </p><p>有个<strong>贝祖定理</strong>：<br>由贝祖定理可知，若存在整数a,b，使得ax+by=z成立，则z一定为x.y最大公因数的整数倍<br>所以最后就是求ab的最大公因数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>) <span class="keyword">return</span> z==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(z&gt;x+y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> a=y==<span class="number">0</span>?GCD(y,x):GCD(x,y);</span><br><span class="line">    <span class="keyword">return</span> z%a==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a%b==<span class="number">0</span>?b:GCD(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200321230907.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode40经典排序算法解决topK问题</title>
      <link href="/posts/88d5f208.html"/>
      <url>/posts/88d5f208.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><blockquote><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]</p></blockquote><h2 id="方法一-高效快排解决-O-N"><a href="#方法一-高效快排解决-O-N" class="headerlink" title="方法一 高效快排解决:O(N)"></a>方法一 高效快排解决:O(N)</h2><p>注意找前K大/前K小问题不需要对整个数组进行O(NlogN)的排序！<br>例如本题，直接通过快排切分排好第K小的数（下标为K-1），那么它左边的数就是比它小的另外K-1个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSearch(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);</span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>因为我们是要找下标为k的元素，第一次切分的时候需要遍历整个数组(0 ~ n)找到了下标是j的元素，假如k比j小的话，那么我们下次切分只要遍历数组(0~k-1)的元素就行啦，反之如果k比j大的话，那下次切分只要遍历数组(k+1～n)的元素就行啦，总之可以看作每次调用partition遍历的元素数目都是上一次遍历的1/2，因此时间复杂度是N + N/2 + N/4 + … + N/N = 2N, 因此时间复杂度<strong>是O(N)</strong>。</p><h2 id="方法二-大根堆-前K小-小根堆（前K大-Java中有现成的PriorityQueue-O-NlogK"><a href="#方法二-大根堆-前K小-小根堆（前K大-Java中有现成的PriorityQueue-O-NlogK" class="headerlink" title="方法二 大根堆(前K小)/小根堆（前K大),Java中有现成的PriorityQueue:O(NlogK)"></a>方法二 大根堆(前K小)/小根堆（前K大),Java中有现成的PriorityQueue:O(NlogK)</h2><p>本题是求前K小，因此用一个容量为K的大根堆，每次poll出最大的数，那堆中保留的就是前K小啦（注意不是小根堆！小根堆的话需要把全部的元素都入堆，那是O(NlogN)，就不是O(NlogK)<br>这个方法比快排慢，但是因为Java中提供了现成的PriorityQueue（默认小根堆）, 所以实现起来最简单，没几行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：</span></span><br><span class="line"><span class="comment">// 1. 若目前堆的大小小于K，将当前数字放入堆中。</span></span><br><span class="line"><span class="comment">// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；</span></span><br><span class="line"><span class="comment">//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span></span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回堆中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三-二叉搜索树-O-NlogK"><a href="#方法三-二叉搜索树-O-NlogK" class="headerlink" title="方法三 二叉搜索树:O(NlogK)"></a>方法三 二叉搜索树:O(NlogK)</h2><p>BST相对于前两种方法没那么常见，但是也很简单，和大根堆的思路差不多～<br>要提的是，与前两种方法相比，BST有一个好处是求得的前K大的数字是有序的。</p><p>因为有重复的数字，所以用的是TreeMap而不是TreeSet（有的语言的标准库自带TreeMultiset，也是可以的）。</p><p>TreeMap的key是数字，value是该数字的个数。<br>我们遍历数组中的数字，维护一个数字总个数为K的TreeMap：<br>1.若目前map中数字个数小于K，则将map中当前数字对应的个数+1；<br>2.否则，判断当前数字与map中最大的数字的大小关系：若当前数字大于等于map中的最大数字，就直接跳过该数字；若当前数字小于map中的最大数字，则将map中当前数字对应的个数+1，并将map中最大数字对应的个数减1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>||k==<span class="number">0</span>) &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];&#125;</span><br><span class="line">        <span class="keyword">int</span> []result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        TreeMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:arr) &#123;</span><br><span class="line">            <span class="comment">//遍历数组，当前map中数字个数小于k，则对应数字个数+1</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; k) &#123;</span><br><span class="line">                map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，取出map中最大的key，判断当前数字与最大的key关系</span></span><br><span class="line">            <span class="comment">//若当前数字比map中最大的数字还大，就直接忽略</span></span><br><span class="line">            <span class="comment">//若前数字比map中最大的数字还小，将当前数字加入map,并将map中的最大数字的个数-1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//map中最大的key</span></span><br><span class="line">            Map.Entry&lt;Integer,Integer&gt; entry = map.lastEntry();</span><br><span class="line">            <span class="keyword">if</span>(entry.getKey()&gt;num) &#123;</span><br><span class="line">                map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//最大key只有1个，则直接去除map中最大的值</span></span><br><span class="line">                <span class="keyword">if</span>(entry.getValue()==<span class="number">1</span>) &#123;</span><br><span class="line">                    map.pollLastEntry();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则最大key的数量-1</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(entry.getKey(),entry.getValue()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回map的元素</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> freq = entry.getValue();</span><br><span class="line">            <span class="keyword">while</span> (freq-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result[index++] = entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1160拼写单词</title>
      <link href="/posts/64609a71.html"/>
      <url>/posts/64609a71.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 <strong>长度之和</strong>。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><blockquote><p>输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”<br>输出：6<br>解释：<br>可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。</p></blockquote><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><blockquote><p>输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”<br>输出：10<br>解释：<br>可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。</p></blockquote><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ol><li>1 &lt;= words.length &lt;= 1000</li><li>1 &lt;= words[i].length, chars.length &lt;= 100</li><li>所有字符串中都仅包含小写英文字母</li></ol><h1 id="解法一：HashMap"><a href="#解法一：HashMap" class="headerlink" title="解法一：HashMap"></a>解法一：HashMap</h1><p>这是种经典的类型，我们考虑用HashMap<strong>统计字母出现的次数</strong>。<br>这里我们既统计字母表中字母出现的次数，也统计单词中字母的次数。如果单词里每种字母出现的次数都<strong>小于等于</strong>字母表中出现的次数，那么就可以表示出来，计入统计。</p><ul><li>首先统计字母表字母次数</li><li>统计单词表字母次数</li><li>单词表字母次数小于等于字母表次数，返回true,统计长度；否则false</li></ul><h2 id="我的代码："><a href="#我的代码：" class="headerlink" title="我的代码："></a>我的代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(chars.length());</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(chars.charAt(i)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(chars.charAt(i), <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(chars.charAt(i), map.get(chars.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; wordMap = <span class="keyword">new</span> HashMap&lt;&gt;(words[i].length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordMap.get(words[i].charAt(j)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                wordMap.put(words[i].charAt(j), <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wordMap.put(words[i].charAt(j), wordMap.get(words[i].charAt(j)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(words[i].charAt(j))==<span class="keyword">null</span>||map.get(words[i].charAt(j)) &lt; wordMap.get(words[i].charAt(j))) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            result += words[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度:O(N^2*logN)<br>空间复杂度:O(N)</p><h1 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h1><p>我们知道题目中只会出现小写字母，所以统计可以用<strong>int s[] = new int[26];</strong></p><h2 id="优化代码："><a href="#优化代码：" class="headerlink" title="优化代码："></a>优化代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []Character = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Character = count(chars);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;words.length;i++) &#123;</span><br><span class="line">             <span class="keyword">int</span> []wordCount = count(words[i]);</span><br><span class="line">             <span class="keyword">if</span>(isCount(Character,wordCount)) &#123;</span><br><span class="line">                 result += words[i].length();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> []count(String string) &#123;</span><br><span class="line">        <span class="keyword">int</span> []s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;string.length();i++) &#123;</span><br><span class="line">            s[string.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCount</span><span class="params">(<span class="keyword">int</span> []Charater,<span class="keyword">int</span> []wordCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Charater[i] &lt; wordCount[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度:"></a>复杂度:</h2><p>时间复杂度:O(N^2)<br>空间复杂度:O(N=26)</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/leetcode1140.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 300最长上升子序列</title>
      <link href="/posts/8743da55.html"/>
      <url>/posts/8743da55.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个无序的整数数组，找到其中最长上升子序列的长度  </p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p></blockquote><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可</li><li>你算法的时间复杂度应该为 O(n2) ，进阶将时间复杂度降低到O（nlogn）</li></ul><h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul><li><strong>状态定义</strong>:<br>用dp[i]的值代表nums前i个数字的最长子序列长度</li><li><strong>转移方程</strong>：<br>设j的范围[0,i),<strong>dp[i] = max(dp[j]+1,dp[i])</strong>,而且满足dp[i]&gt;dp[j]才有可能更新状态。表示第i个元素之前找出最大的最长上升子序列长度</li><li><strong>初始状态</strong>：<br>dp[i]的所有元素置1，因为每个元素都至少可以单独成为子序列<h3 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a><strong>复杂度</strong>：</h3></li><li><strong>时间复杂度</strong>：O（N^2）遍历dp数组需要O（N）,计算每个dp[i]需要O（N）</li><li><strong>空间复杂度</strong>：O（N） 数组dp</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i] 表示以nums[i]结尾的最长上升子序列的长度</span></span><br><span class="line">        <span class="comment">//dp[i] = max(dp[i],dp[j]+1)</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> []dp= <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">                <span class="comment">//状态转移方程dp[i] = max(dp[j]+1) ,nums[j] &lt; nums[i]</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxL &lt; dp[i]) &#123;</span><br><span class="line">                maxL = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高并发Synchronized</title>
      <link href="/posts/3d3b131f.html"/>
      <url>/posts/3d3b131f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、Sysnchronized简介"><a href="#一、Sysnchronized简介" class="headerlink" title="一、Sysnchronized简介"></a>一、Sysnchronized简介</h1><p> Sysnchronized：能够保证在<strong>同一时刻</strong>最多只有<strong>一个</strong>线程执行该段代码<br> 创建线程的两种方法:</p><ol><li><p>继承Thread类</p></li><li><p>实现Runnable接口  </p><p>thread1.join()方法：等待线程1执行完后才接着执行</p><h1 id="二、Sysnchronized两种用法（对象锁和类锁）"><a href="#二、Sysnchronized两种用法（对象锁和类锁）" class="headerlink" title="二、Sysnchronized两种用法（对象锁和类锁）"></a>二、Sysnchronized两种用法（对象锁和类锁）</h1><ul><li><font size="4"><strong>对象锁</strong></font><br>包括<font color="red">方法锁</font>（默认锁对象为this当前实例对象）和<font color="red">同步代码块锁</font>（自己指定锁对象）  </li></ul><p><strong>第一种</strong>：<font color="red">同步代码块锁</font>（自己指定锁对象） </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObject</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObject instance = <span class="keyword">new</span> SynchronizedObject();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我是对象锁的代码块形式。我叫"</span> +</span><br><span class="line">                    Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span>(t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码结果：Thread1  Thread2串行执行，此时用的锁是this<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97.png" alt><br>现在设置两把不同的锁lock1和lock2，分别有两段不同的同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SynchronizedObject instance = <span class="keyword">new</span> SynchronizedObject();</span><br><span class="line"><span class="keyword">static</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">static</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是lock1。我叫"</span> +</span><br><span class="line">                Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"lock1运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是lock2。我叫"</span> +</span><br><span class="line">                Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"lock2运行结束"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：首先，线程0获取lock1锁并执行代码块；3s后线程0lock1执行结束。<strong>然后Thread0 和Thread1并行的获取Lock2、Lock1</strong>；Thread0lock2部分和Thread1lock1部分同时结束；Thread1获取lock2锁；3s后Thread1lock2执行结束。<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%972.png" alt><br><strong>第二种</strong>：<font color="red">方法锁形式</font>synchronized修饰普通方法，锁对象默认为this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是对象锁的方法修饰符形式，我叫"</span> +</span><br><span class="line">            Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+</span><br><span class="line">            <span class="string">"运行结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font size="4"><strong>类锁</strong></font><br>指Sysnchronized修饰<font color="red">静态</font>的方法或指定锁为<font color="red">CLASS对象</font><br>类锁：Java类可能有很多个对象，但只有1个Class对象  </li></ul><p><strong>形式1</strong>：synchronized加在static方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SynchronizedObject instance1 = <span class="keyword">new</span> SynchronizedObject();</span><br><span class="line"><span class="keyword">static</span> SynchronizedObject instance2 = <span class="keyword">new</span> SynchronizedObject();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是类锁的第一种形式，我叫"</span> +</span><br><span class="line">            Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+</span><br><span class="line">            <span class="string">"运行结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/%E7%B1%BB%E9%94%81.png" alt><br><strong>形式2：</strong> synchronized（*.class）代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedObject<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是类锁的第二种形式，我叫"</span> +</span><br><span class="line">                Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                <span class="string">"运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/%E7%B1%BB%E9%94%812.png" alt></p><hr><h2 id="多线程访问同步方法的7种情况（面试常考）"><a href="#多线程访问同步方法的7种情况（面试常考）" class="headerlink" title="多线程访问同步方法的7种情况（面试常考）"></a><font color="red">多线程访问同步方法的7种情况（面试常考）</font></h2><ol><li>两个线程同时访问<strong>一个对象</strong>的同步方法</li><li>两个线程访问的是<strong>两个对象</strong>的同步方法</li><li>两个线程访问的是synchronized的<strong>静态</strong>方法</li><li>同时访问<strong>同步方法</strong>与<strong>非同步方法</strong></li><li>访问同一个对象的<strong>不同</strong>的普通同步方法</li><li>同时访问<strong>静态</strong>synchoronized和<strong>非静态</strong>synchronized方法</li><li>方法抛<strong>异常</strong>后，会<strong>释放锁</strong></li></ol><hr><ol><li>两个线程串行执行</li><li>两个对象的同步方法各自有一把锁，互不干扰，结果是两个线程并行执行</li><li>synchronized修饰的静态方法加的是类锁，所有对象共用一把锁，所以两个线程串行执行</li><li>同步方法的实例和非同步方法的实例之间互不影响，所以两个线程并行执行</li><li>访问同一个对象的不同普通同步方法，一把锁只能同时被一个线程获取，所以是串行执行。</li><li>静态synchoronized修饰的方法加的是类锁，非静态synchronized加的是对象锁，实例彼此不受影响，所以并行执行</li><li>使用throw new RuntimeException()异常后，JVM会自动释放锁。（lock方法需要在finally后释放）  <h2 id="4点核心思想"><a href="#4点核心思想" class="headerlink" title="4点核心思想:"></a><strong>4点核心思想:</strong></h2></li><li>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待(对应第1、5种情况)  </li><li>每个实例都对应有自己的一把锁，不同实例之间互不影响；例外：锁对象是*,class以及synchronized修饰的是static方法时，所有对象共用同一把类锁（对应2、3、4、6情况）</li><li>无论是方法正常执行完毕或者方法抛出异常，都会释放锁(对应第7种情况)</li><li>如果存在一种情况 在被synchronized修饰的方法内调用一个非同步方法，<br>那么调用这个非同步方法不是线程安全的</li></ol><h1 id="三、-Synchronized的性质"><a href="#三、-Synchronized的性质" class="headerlink" title="三、 Synchronized的性质"></a>三、 Synchronized的性质</h1><ol><li>可重入<br>可重入指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。<br>（我已经获得这把锁，现在再次请求这把锁而无需释放当前锁就叫做可重入）<br>Java中可重入锁有：<font color="red">Synchronized</font>和<font color="red">ReentrantLock</font><br>好处：避免死锁、提升封装性<br>粒度：线程而非调用（用3种情况来说明和pthread的区别）——同一线程层面  </li></ol><ul><li>情况1：证明同一个方法是可重入的</li><li>情况2：证明可重入不要求是同一个方法</li><li>情况3：证明可重入不要求是同一个类中的</li></ul><ol start="2"><li>不可中断<br>一旦这个锁被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程<font color="red">释放</font>这个锁。<br> 如果别人永远不释放锁那么只能永远等下去。（Lock类拥有中断或退出的能力）<h1 id="四、深入原理"><a href="#四、深入原理" class="headerlink" title="四、深入原理"></a>四、深入原理</h1></li></ol><ul><li>加锁和释放锁的原理：现象、时机、深入JVM看字节码  <h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4>每一个类的实例对应着一把锁，而每一个synchronized方法都必须首先获得调用该方法的类的实例的   锁，才能执行。否则线程就会阻塞，而方法一旦执行，就会独占这把锁，直到该方法返回，或者抛出异常，才将锁释放。释放之后，其他被阻塞的线程才能获得这把锁，重新进入可执行的状态。  <h4 id="获取和释放锁的时机：内置锁"><a href="#获取和释放锁的时机：内置锁" class="headerlink" title="获取和释放锁的时机：内置锁"></a>获取和释放锁的时机：内置锁</h4>获取这个锁的时机就是进入这个锁保护的同步代码块或方法中，退出或抛出异常会释放这个锁。  <h4 id="等价代码"><a href="#等价代码" class="headerlink" title="等价代码"></a>等价代码</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是Synchronized形式的锁"</span>)；</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是Lock形式的锁"</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深入JVM看字节码"><a href="#深入JVM看字节码" class="headerlink" title="深入JVM看字节码"></a>深入JVM看字节码</h4><p>&emsp;<strong>synchronize用的锁是java对象头里的一个字段（每一个对象都有一个对象头，对象头可以存储很多信息，其中有一部分就是用来存储synchronize关键字的锁）</strong><br>&emsp;获取锁和释放锁是基于monitor对象来实现同步方法和同步代码块的，Monitor对象主要是两个指令，一个是Monitorenter(插入到同步代码块开始的位置)，Monitorexit(退出，插入到方法结束和退出时候)。JVM规范要求一个enter对应一个或多个exit。每一个对象都有一个monitor和他关联，并且monitor被持有后，就会处于锁定状态，当线程执行到Monitorenter指令时，会尝试获取这个对象对应的monitor的所有权，也是尝试获取对象的锁。<br>&emsp;原理：Monitorenter和Monitorexit在执行的时候会使对象的锁计数加1或者减1，和操作系统中的PV操作（多线程对临界资源的访问）很像，每一个对象都和一个Monditor相关联。<br>&emsp;释放的过程就是将Monditor的计数器减1，减完之后变成0就意味着当前线程不在拥有对Monditor的所有权，就是解锁，如果减完之后不是0，意味着刚才是可重入进来的，所以还继续持有这把锁，最终减到0之后，不仅意味着释放锁了，还意味着刚才被阻塞的线程，会再次尝试获取对该把锁的所有权。  </p><ul><li><strong>可重入原理</strong>：加锁次数计数器<br>JVM负责跟踪对象被加锁的次数；<br>有个monitor计数器，线程第一次给对象加锁的时候，计数变为1.每当这个相同的线程在此对象上再次获得锁时，计数会递增；<br>任务结束离开，则会执行monitorexit，计数递减，当计数为0时锁完全被释放；</li><li><strong>可见性原理</strong>：Java内存模型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt><br>&emsp;被synchronized修饰后，被锁住的对象所做的任何操作，都要在释放锁之前，从线程内存写回到主内存中（不会存在线程内存和主内存不一致的情况）。同样，在进入代码块得到锁之后，被锁定对象的数据也是直接从主内存中读取出来。</p><h1 id="五、缺陷"><a href="#五、缺陷" class="headerlink" title="五、缺陷"></a>五、缺陷</h1><ul><li>效率低：锁的释放情况少，试图获得锁时不能设定超时，不能中断一个正在试图获得锁的线程。</li><li>不够灵活(读写锁更灵活)：加锁和释放的时机单一，每个锁仅有单一的条件(某个对象)，可能是不够的</li><li>无法知道是否成功获取到锁<br>对比Lock接口的方法：</li></ul><ol><li>lock();//获取锁</li><li>unlock();//释放锁</li><li>tryLock();//判断锁是否可用。返回值为：boolean;</li><li>tryLock(time,TimeUnit);//在规定的时间内，如果未获得锁，则就放弃。 <h1 id="六、常见面试问题"><a href="#六、常见面试问题" class="headerlink" title="六、常见面试问题"></a>六、常见面试问题</h1></li><li>使用注意点：锁对象不能为空（锁的信息保存在对象头中）、作用域不宜过大（大部分代码串行，影响效率）、避免死锁</li><li>如何选择Lock和synchronized关键字？<ol><li>建议都不使用，可以使用java.util.concurrent包中的Automic类、countDown等类</li><li>优先使用现成工具，如果没有就优先使用synchronized关键字，好处是写劲量少的代码就能实现功能。如果  需要灵活的加解锁机制，则使用Lock接口</li><li>多线程访问同步方法的各种情况<h1 id="七、思考题"><a href="#七、思考题" class="headerlink" title="七、思考题"></a>七、思考题</h1></li></ol></li><li>多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的是哪个线程？</li><li>synchronized使得同时只有一个线程可以执行，性能较差，有什么办法可以提升性能？  </li></ol><p><strong>答</strong>：优化synchronized的使用范围、使用其他类型lock(读写锁等)<br>3. 如何更灵活地控制锁的获取和释放（释放锁的时机被规定死了怎么办）<br>4. 什么是锁的升级、降级？什么是JVM里的偏斜锁、轻量级锁、重量级锁？</p><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>一句话介绍synchronized：<br><strong>JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE部分 </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高级知识 </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客绑定域名+图床+CDN加速</title>
      <link href="/posts/a4a5d335.html"/>
      <url>/posts/a4a5d335.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><h2 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h2><p>国内的域名服务商有新网，腾讯云，还有阿里云的万网等。下面以阿里云的万网为例：<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/%E4%B8%87%E7%BD%91%E5%9F%9F%E5%90%8D.png" alt><br>在万网购买了自己心仪的域名后，进入阿里云的<strong>管理控制台-域名与网站-域名</strong>就可以看到购买的域名此时的域名状态是未实名认证的，然后就是<strong>实名认证</strong></p><h2 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2. 域名解析"></a>2. 域名解析</h2><p>首先获取自己 github 的二级域名的 IP地址，windows 下直接在 cmd 里 Ping 一下自己的博客就会得到 IP 地址：  </p><blockquote><p>ping username.github.io,username为自己的github用户名</p></blockquote><p>下面通过 DNS域名解析将购买的域名指向 github 的二级域名：username.github.io，进入阿里云的管理控制台-域名与网站-云解析 DNS，进入域名的解析设置，点击新手指导，将得到的 IP 地址填到记录值一栏，点击确定就 OK 了。填完以后的解析列表会出现：<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt><br>记录值就是自己 github 的二级域名的 IP地址。</p><h2 id="3-设置CNAME"><a href="#3-设置CNAME" class="headerlink" title="3. 设置CNAME"></a>3. 设置CNAME</h2><p>在 本地hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。比如：<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/CNAME.png" alt><br>在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如：<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/githubpages.png" alt><br>到此为止，你可以使用你的新域名啦~</p><h1 id="PicGo-Github搭建图床"><a href="#PicGo-Github搭建图床" class="headerlink" title="PicGo+Github搭建图床"></a>PicGo+Github搭建图床</h1><p>我们使用的是<strong>PicGo+GitHub</strong>来搭建免费的图床。国内很多云服务比如七牛云，阿里云都可以用做图床，我也试过，很多都需要域名备案所以要购买云服务器（太穷了。。）这种方法使用GitHub的仓库做图床，PicGo上传神器，简直不要太爽~</p><h2 id="1-新建Github仓库"><a href="#1-新建Github仓库" class="headerlink" title="1. 新建Github仓库"></a>1. 新建Github仓库</h2><p>新建一个存储仓库，仓库名自定义。</p><h2 id="2-生成token"><a href="#2-生成token" class="headerlink" title="2. 生成token"></a>2. 生成token</h2><p>点击github个人头像里的<strong>Settings</strong>-&gt;左下角<strong>Developer settings</strong>-&gt; <strong>Personal access tokens</strong>-&gt;点击<strong>Generate new token</strong>生成新的token-&gt;在Note里自定义命名，仓库repo权限全选，点击<strong>Generate token</strong>即可看到显示的token页面，它只会显示一次，关闭页面后再打开这个页面就不会显示了。复制token值粘贴到文本文档中，先保存下来，后面配置PicGo要用到<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/token.png" alt></p><h2 id="3-配置PicGO"><a href="#3-配置PicGO" class="headerlink" title="3. 配置PicGO"></a>3. 配置PicGO</h2><p>下载安装完PicGO后，进行配置，如下图：<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/picgo.png" alt></p><ul><li>设定仓库名：这个是刚刚第一步所新建仓库的名称，此处填写格式username/repo。</li><li>设定分支名：master，采用默认分支即可</li><li>设定Token：此处填写上一步得到的Token，添加到输入框即可。</li><li>指定存储路径：自定义，例：images/，相当于在刚刚新建的仓库下新建了一个文件夹。</li><li>设定自定义域名：格式：<a href="https://cdn.jsdelivr.net/gh/username/repo，username为GitHub用户名，repo为新建的仓库，用于存储图片" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/username/repo，username为GitHub用户名，repo为新建的仓库，用于存储图片</a>  </li></ul><p>完成上面的操作，图床就算配置好了。<br>PicGO支持Markdown,html,url等图片形式的上传</p><h1 id="使用Jsdelivr-CDN加速"><a href="#使用Jsdelivr-CDN加速" class="headerlink" title="使用Jsdelivr CDN加速"></a>使用Jsdelivr CDN加速</h1><p>Matery主题新版本中已经集成好了CDN加速，只需要： 打开主题配置文件<strong>config.yml</strong> 最底部说明：  </p><p>CDN访问加速<br>第一次使用本功能，一定要先配置url，再<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code>部署到GitHub的仓库，注意！必须是GitHub的仓库！<br>如果必须要使用国内的coding或者gitee，可以采用双部署，同时将网站部署到两个仓库（其中一个必须是GitHub的仓库）<br>URL配置规则（例子如下）： <a href="https://cdn.jsdelivr.net/gh/你的GitHub用户名/你的仓库名" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/你的GitHub用户名/你的仓库名</a><br>如果想关闭此功能，将 url地址 注释或删除即可！</p>]]></content>
      
      
      <categories>
          
          <category> hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> cdn </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot构建电商秒杀项目(二) 用户模块开发</title>
      <link href="/posts/a3a191c9.html"/>
      <url>/posts/a3a191c9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="2-1-项目整体框架"><a href="#2-1-项目整体框架" class="headerlink" title="2.1 项目整体框架"></a>2.1 项目整体框架</h2><p>本项目采用springBoot开发，项目架构是Spring MVC框架<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/2_01.png" alt="2_01"><br><strong>controller层</strong>：与前端页面UI交互的层<br><strong>viewobject层</strong>：视图，封装了向前端展示的数据，避免领域模型的某些敏感数据直接传给前端<br><strong>dao层</strong>：与底层数据库交互的层，进行数据库的增删改查<br><strong>dataobject层</strong>：数据库表对于Java实体类的映射，是数据库表中数据的封装<br><strong>model层</strong>：领域模型，将不同的表但属于一个领域的字段的整合<br><strong>service层</strong>：处于上层controller与下层dao层的中间层，处理各种逻辑业务和服务请求<br><strong>error层</strong>：统一错误的格式，拦截tomcat不能处理的各类异常与错误<br><strong>response层</strong>：返回给前端统一的格式(response+data)  </p><h2 id="2-2-定义通用的返回对象——返回正确信息"><a href="#2-2-定义通用的返回对象——返回正确信息" class="headerlink" title="2.2 定义通用的返回对象——返回正确信息"></a>2.2 定义通用的返回对象——返回正确信息</h2><p>考虑到我们的程序如果出错，返回给前端的缺少错误信息，用户体验不好，所以我们定义一个CommonReturnType类用status+data的格式来处理json序列化，避免使用HttpStatusCode和内嵌的tomcat error页</p><h3 id="创建CommonReturnType类"><a href="#创建CommonReturnType类" class="headerlink" title="创建CommonReturnType类"></a>创建CommonReturnType类</h3><p>在项目目录新建一个response文件夹，创建CommonReturnType类，返回的类是status(请求处理结果)+data(错误信息)格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReturnType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表明对应请求的返回处理结果“success”或“fail”</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若status=success，则data内返回前端需要的json数据</span></span><br><span class="line">    <span class="comment">//若status=fail，则data内使用通用的错误码格式</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个通用的创建方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(result, <span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result,String status)</span> </span>&#123;</span><br><span class="line">        CommonReturnType type = <span class="keyword">new</span> CommonReturnType();</span><br><span class="line">        type.setStatus(status);</span><br><span class="line">        type.setData(result);</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-定义通用的返回对象——返回错误的信息"><a href="#2-3-定义通用的返回对象——返回错误的信息" class="headerlink" title="2.3 定义通用的返回对象——返回错误的信息"></a>2.3 定义通用的返回对象——返回错误的信息</h2><p>在项目目录下新建一个error文件，定义标准的错误返回信息（errCode+errMsg格式）</p><h3 id="1-创建CommonError接口"><a href="#1-创建CommonError接口" class="headerlink" title="1. 创建CommonError接口"></a>1. 创建CommonError接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建EmBusinessError实现类"><a href="#2-创建EmBusinessError实现类" class="headerlink" title="2. 创建EmBusinessError实现类"></a>2. 创建EmBusinessError实现类</h3><p>EmBusinessError类称为包装器业务异常类，为枚举类，也有自己的成员对象和成员函数。定义通用的错误码为10001，10002未知错误等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EmBusinessError implements CommonError&#123;</span><br><span class="line">    <span class="comment">//通用错误类型10001</span></span><br><span class="line">    <span class="comment">//很多不合法的情况可设置统一错误码</span></span><br><span class="line">    PARAMETER_VALIDATION_ERROR(<span class="number">10001</span>,<span class="string">"参数不合法"</span>),</span><br><span class="line"></span><br><span class="line">    UNKNOW_ERROR(<span class="number">10002</span>,<span class="string">"未知错误"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//20000开头为用户信息相关错误定义</span></span><br><span class="line">    USER_NOT_EXIST(<span class="number">20001</span>,<span class="string">"用户不存在"</span>),</span><br><span class="line">    USER_LOGIN_FAIL(<span class="number">20002</span>,<span class="string">"用户手机号或密码不正确"</span>),</span><br><span class="line">    USER_NOT_LOGIN(<span class="number">20003</span>,<span class="string">"用户还未登陆"</span>),</span><br><span class="line">    <span class="comment">//30000开头为交易信息错误</span></span><br><span class="line">    STOCK_NOT_ENOUGH(<span class="number">30001</span>,<span class="string">"库存不足"</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errCode;</span><br><span class="line">    <span class="keyword">private</span> String errMsg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmBusinessError</span><span class="params">(<span class="keyword">int</span> errCode,String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errCode = errCode;</span><br><span class="line">        <span class="keyword">this</span>.errMsg = errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errMsg = errMsg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-包装器业务异常类实现"><a href="#3-包装器业务异常类实现" class="headerlink" title="3. 包装器业务异常类实现"></a>3. 包装器业务异常类实现</h3><p>包装器业务异常类不仅可以直接接收EmBusinessError的传参用于构造业务异常，也可以接收自定义errMsg的方式构造业务异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">CommonError</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//commonError其实就是EmBusinessError类</span></span><br><span class="line">    <span class="keyword">private</span> CommonError commonError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="comment">//直接接收EmBusinessError的传参用于构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类初始化</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收自定义errMsg的方式构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError,String errMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrMsg(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.commonError.getErrCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.commonError.getErrMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrMsg(errMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-定义通用的返回对象——异常处理"><a href="#2-4-定义通用的返回对象——异常处理" class="headerlink" title="2.4 定义通用的返回对象——异常处理"></a>2.4 定义通用的返回对象——异常处理</h2><h3 id="定义ExceptionHandler"><a href="#定义ExceptionHandler" class="headerlink" title="定义ExceptionHandler"></a>定义ExceptionHandler</h3><p>定义exceptionHandler解决未被controller层吸收的exception</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义exceptionHandler解决未被controller层吸收的exception</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Object</span> <span class="title">handlerException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            BusinessException businessException = (BusinessException) ex;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, businessException.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, businessException.getErrMsg());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, EmBusinessError.UNKNOWN_ERROR.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, EmBusinessError.UNKNOWN_ERROR.getErrMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(responseData, <span class="string">"fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-使用SpringMVC方式开发用户信息"><a href="#2-5-使用SpringMVC方式开发用户信息" class="headerlink" title="2.5 使用SpringMVC方式开发用户信息"></a>2.5 使用SpringMVC方式开发用户信息</h2><h3 id="1-创建UserModel模型"><a href="#1-创建UserModel模型" class="headerlink" title="1. 创建UserModel模型"></a>1. 创建UserModel模型</h3><p>用户信息包括用户名name,性别gender,年龄age，手机号telphone，注册码registerMode,第三方ID thirdPartId,加密密码encrptPassword</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引入NotBlank注释，不能为空字符串或NULL,否则报错提示</span></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"用户名不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"性别不能不填写"</span>)</span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"年龄不能不填写"</span>)</span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">0</span>,message = <span class="string">"年龄必须大于0"</span>)</span><br><span class="line">    <span class="meta">@Max</span>(value = <span class="number">150</span>,message = <span class="string">"年龄必须小于150"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"手机号不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"密码不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String registerMode;</span><br><span class="line">    <span class="keyword">private</span> String thirdPartId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String encrptPassword;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建UserController层"><a href="#2-创建UserController层" class="headerlink" title="2.创建UserController层"></a>2.创建UserController层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getUser</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span> Integer id) <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用service服务获取对应Id的用户对象并返回给前端</span></span><br><span class="line">        UserModel userModel = userService.getUserById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若获取的对应用户信息不存在</span></span><br><span class="line">        <span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_EXIST);</span><br><span class="line">            <span class="comment">//userModel.setEncrptPassword("123");</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将核心领域模型用户对象转化成可供UI使用的viewobject对象</span></span><br><span class="line">        UserVO userVO = convertFromModel(userModel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回通用对象</span></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(userVO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> UserVO <span class="title">convertFromModel</span> <span class="params">(UserModel userModel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">        BeanUtils.copyProperties(userModel,userVO);</span><br><span class="line">        <span class="keyword">return</span> userVO;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过前端传来的id，在userService中查询userModel对象，然后由于userModel中包含有用户的密码，不能直接传递给前端，所以要定义ViewObject类<strong>UserVO</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line">    <span class="keyword">private</span> String thirdPartId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-创建UserService类"><a href="#3-创建UserService类" class="headerlink" title="3. 创建UserService类"></a>3. 创建UserService类</h3><p>UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserModel <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>UserServiceImpl实现类<br>UserServiceImpl实现类首先通过<strong>用户id</strong>查找对应用户的<strong>userDO</strong>，然后在<strong>userPasswordDOMapper</strong>中查询对应用户的加密密码信息，最后将<strong>userDO</strong>和<strong>userPasswordDO</strong>整合在一起实现<strong>converFromDataObject</strong>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserModel <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用userdomapper获取到对应的用户dataobject</span></span><br><span class="line">        UserDO userDO = userDOMapper.selectByPrimaryKey(id);</span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过用户id获取对应用户的加密密码信息</span></span><br><span class="line">        UserPasswordDO userPasswordDO = userPasswordDOMapper.selectByUserId(userDO.getId());</span><br><span class="line">        <span class="keyword">return</span> convertFromDataObject(userDO,userPasswordDO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//userDO+userPassword 组装DataObject-&gt;UserModel</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UserModel <span class="title">convertFromDataObject</span><span class="params">(UserDO userDo, UserPasswordDO userPasswordDO)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userDo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UserModel userModel = <span class="keyword">new</span> UserModel();</span><br><span class="line">        <span class="comment">//copyProperties 将userDo赋值给userModel</span></span><br><span class="line">        BeanUtils.copyProperties(userDo,userModel);</span><br><span class="line">        <span class="keyword">if</span>(userPasswordDO!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            userModel.setEncrptPassword(userPasswordDO.getEncriptPassword());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userModel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-用户模型管理——otp验证码获取"><a href="#2-6-用户模型管理——otp验证码获取" class="headerlink" title="2.6 用户模型管理——otp验证码获取"></a>2.6 用户模型管理——otp验证码获取</h2><h3 id="1-创建getotp方法"><a href="#1-创建getotp方法" class="headerlink" title="1. 创建getotp方法"></a>1. 创建getotp方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest httpServletRequest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户获取otp短信接口</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getotp"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getOtp</span><span class="params">(@RequestParam(name = <span class="string">"telphone"</span>)</span> String telphone) </span>&#123;</span><br><span class="line">        <span class="comment">//需要按照一定的规则生成OTP验证码</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomInt = random.nextInt(<span class="number">99999</span>);</span><br><span class="line">        randomInt += <span class="number">10000</span>;</span><br><span class="line">        String otpCode = String.valueOf(randomInt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将OTP验证码同对应用户的手机号关联，使用httpsession的方式绑定手机号与OTPCDOE</span></span><br><span class="line">        httpServletRequest.getSession().setAttribute(telphone, otpCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将OTP验证码通过短信通道发送给用户，省略</span></span><br><span class="line">        System.out.println(<span class="string">"telphone="</span> + telphone + <span class="string">"&amp;otpCode="</span> + otpCode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-引入Metronic模板"><a href="#2-引入Metronic模板" class="headerlink" title="2. 引入Metronic模板"></a>2. 引入Metronic模板</h3><p>新建static文件夹保存模板文件，实现前端getotp.html文件,使用jQuary与Ajax实现与后端异步通信</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/assets/global/plugins/jquery-1.11.0.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>获取otp信息<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>手机号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"手机号"</span> <span class="attr">name</span>=<span class="string">"telphone"</span> <span class="attr">id</span>=<span class="string">"telphone"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"getotp"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">                获取otp短信</span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//绑定otp的click事件用于向后端发送获取手机验证码的请求</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#getotp"</span>).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> telphone=$(<span class="string">"#telphone"</span>).val();</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (telphone==<span class="literal">null</span> || telphone==<span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                alert(<span class="string">"手机号不能为空"</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">//映射到后端@RequestMapping(value = "/getotp", method = &#123;RequestMethod.POST&#125;, consumes = &#123;CONTENT_TYPE_FORMED&#125;)</span></span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">                type:<span class="string">"POST"</span>,</span></span><br><span class="line"><span class="actionscript">                contentType:<span class="string">"application/x-www-form-urlencoded"</span>,</span></span><br><span class="line"><span class="actionscript">                url:<span class="string">"http://localhost:8080/user/getotp"</span>,</span></span><br><span class="line">                data:&#123;</span><br><span class="line"><span class="javascript">                    <span class="string">"telphone"</span>:$(<span class="string">"#telphone"</span>).val(),</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="actionscript">                success:<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">if</span> (data.status==<span class="string">"success"</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                        alert(<span class="string">"otp已经发送到了您的手机，请注意查收"</span>);</span></span><br><span class="line"><span class="actionscript">                    &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                        alert(<span class="string">"otp发送失败，原因为"</span> + data.data.errMsg);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line"><span class="actionscript">                error:<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    alert(<span class="string">"otp发送失败，原因为"</span>+data.responseText);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进行测试，测试controller层getotp方法，但是发送失败，出现以下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getotp.html?_ijt=cqdae6hmhq9069c9s4muooakju:<span class="number">1</span> Access to XMLHttpRequest at <span class="string">'http://localhost:8080/user/getotp'</span> from origin <span class="string">'http://localhost:63342'</span> has been blocked by CORS policy: No <span class="string">'Access-Control-Allow-Origin'</span> header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>经过分析发现是出现了<font color="red">跨域请求错误</font><br>解决办法是在Controller层上加入<font color="red">@CrossOrigin</font>注解</p><h2 id="2-7-用户模型管理——注册功能实现"><a href="#2-7-用户模型管理——注册功能实现" class="headerlink" title="2.7 用户模型管理——注册功能实现"></a>2.7 用户模型管理——注册功能实现</h2><h3 id="1-Controller层部分"><a href="#1-Controller层部分" class="headerlink" title="1.Controller层部分"></a>1.Controller层部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户注册接口</span></span><br><span class="line"> <span class="meta">@RequestMapping</span>(value = <span class="string">"/register"</span>,method = &#123;RequestMethod.POST&#125;,consumes = &#123;CONTENT_TYPE_FORMED&#125;)</span><br><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">register</span><span class="params">(@RequestParam(name=<span class="string">"telphone"</span>)</span> String telphone,</span></span><br><span class="line"><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(name=<span class="string">"otpCode"</span>)</span> String otpCode,</span></span><br><span class="line"><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(name=<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(name=<span class="string">"gender"</span>)</span>Byte gender,</span></span><br><span class="line"><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(name=<span class="string">"age"</span>)</span> Integer age,</span></span><br><span class="line"><span class="function">                                  @<span class="title">RequestParam</span><span class="params">(name=<span class="string">"password"</span>)</span> String password) <span class="keyword">throws</span> BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">  <span class="comment">//验证手机号和对应的otpcode相符合</span></span><br><span class="line">  String inSessionOptCode = (String) <span class="keyword">this</span>.httpServletRequest.getSession().getAttribute(telphone);</span><br><span class="line">  <span class="keyword">if</span>(!StringUtils.equals(inSessionOptCode,otpCode))&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"短信验证码不符合"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用户的注册流程</span></span><br><span class="line">  UserModel userModel = <span class="keyword">new</span> UserModel();</span><br><span class="line"></span><br><span class="line">  userModel.setName(name);</span><br><span class="line">  userModel.setAge(age);</span><br><span class="line">  userModel.setGender(gender);</span><br><span class="line">  userModel.setTelphone(telphone);</span><br><span class="line">  userModel.setRegisterMode(<span class="string">"byphone"</span>);</span><br><span class="line">  userModel.setEncrptPassword(<span class="keyword">this</span>.EncodeByMd5(password));</span><br><span class="line"></span><br><span class="line">  userService.register(userModel);</span><br><span class="line">  <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//JDK MD5方式实现只支持16位，所以修改为64位</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">EncodeByMd5</span><span class="params">(String str)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, UnsupportedEncodingException </span>&#123;</span><br><span class="line">     <span class="comment">//确定计算方法</span></span><br><span class="line">     MessageDigest md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">     BASE64Encoder base64Encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">     <span class="comment">//加密字符串</span></span><br><span class="line">     String newstr = base64Encoder.encode(md5.digest(str.getBytes(<span class="string">"utf-8"</span>)));</span><br><span class="line">    <span class="keyword">return</span> newstr;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>引入做输入校验的依赖</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Service层部分"><a href="#2-Service层部分" class="headerlink" title="2. Service层部分"></a>2. Service层部分</h3><p>UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> BusinessException</span>;</span><br></pre></td></tr></table></figure><p>UserServiceImpl实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">//@Transactional保证UserDO和UserPasswordDo在一个事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Validate来校验</span></span><br><span class="line">        ValidationResult result = validator.validate(userModel);</span><br><span class="line">        <span class="keyword">if</span>(result.isHasErrors()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,result.getErrMsg());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//实现model转换成dataObject</span></span><br><span class="line">        UserDO userDO = convertFromModel(userModel);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            userDOMapper.insertSelective(userDO);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (DuplicateKeyException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"手机号已重复注册"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        userModel.setId(userDO.getId());</span><br><span class="line">        UserPasswordDO userPasswordDO = convertPasswordFromModel(userModel);</span><br><span class="line">        userPasswordDOMapper.insertSelective(userPasswordDO);</span><br><span class="line">        <span class="comment">//使用insertSelective而不使用insert的原因：</span></span><br><span class="line">        <span class="comment">//因为insertSelective是当某一字段不为空时插入数据，为null不改变；而insert操作可能会造成数据覆盖成null</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意的有以下方面：</p><ul><li>数据库增的请求不用insert而用<font color="red">insertSelective</font>,因为insertSelective允许输入为空</li><li>跨域请求要加上<font color="red">@CrossOrigin(allowCredentials = “true”,allowedHeaders = “*”)</font> 实现session共享</li><li>为了保证数据库手机号的唯一性，还要在数据库添加<font color="red">UNIQUE索引</font></li></ul><h3 id="3-前端页面"><a href="#3-前端页面" class="headerlink" title="3. 前端页面"></a>3. 前端页面</h3><p>在getotp页面添加注册成功的跳转页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.status==<span class="string">"success"</span>) &#123;</span><br><span class="line">        alert(<span class="string">"otp已经发送到了您的手机，请注意查收"</span>);</span><br><span class="line">        <span class="built_in">window</span>.location.href=<span class="string">"register.html"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"otp发送失败，原因为"</span> + data.data.errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="2-8-用户模型管理——登陆功能实现"><a href="#2-8-用户模型管理——登陆功能实现" class="headerlink" title="2.8 用户模型管理——登陆功能实现"></a>2.8 用户模型管理——登陆功能实现</h2><h3 id="1-Controller层部分-1"><a href="#1-Controller层部分-1" class="headerlink" title="1. Controller层部分"></a>1. Controller层部分</h3><p>用户登陆的主要流程包括：</p><ul><li>入参校验</li><li>校验用户登陆是否合法</li><li>将登陆凭证加入用户登陆成功的session中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户登录接口</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>,method = &#123;RequestMethod.POST&#125;,consumes = &#123;CONTENT_TYPE_FORMED&#125;)</span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">login</span><span class="params">(@RequestParam(name = <span class="string">"telphone"</span>)</span>String telphone,</span></span><br><span class="line"><span class="function">                                 @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"password"</span>)</span>String password) <span class="keyword">throws</span> BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">       <span class="comment">//入参校验</span></span><br><span class="line">       <span class="keyword">if</span>(org.apache.commons.lang3.StringUtils.isEmpty(telphone)||</span><br><span class="line">           StringUtils.isEmpty(password))&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="comment">//用户登录服务，用来校验用户登录是否合法</span></span><br><span class="line">       UserModel userModel = userService.validateLogin(telphone,<span class="keyword">this</span>.EncodeByMd5(password));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//将登录凭证加入到用户登陆成功的session内</span></span><br><span class="line">       <span class="keyword">this</span>.httpServletRequest.getSession().setAttribute(<span class="string">"IS_LOGIN"</span>,<span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">this</span>.httpServletRequest.getSession().setAttribute(<span class="string">"LOGIN_USER"</span>,userModel);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-Service部分"><a href="#2-Service部分" class="headerlink" title="2. Service部分"></a>2. Service部分</h3><p>Service接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserModel <span class="title">validateLogin</span><span class="params">(String telphone,String encrptPassword)</span> <span class="keyword">throws</span> BusinessException</span>;</span><br></pre></td></tr></table></figure><p>ServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserModel <span class="title">validateLogin</span><span class="params">(String telphone, String encrptPassword)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">        <span class="comment">//通过用户的手机获取用户信息</span></span><br><span class="line">        UserDO userDO = userDOMapper.selectByTelphone(telphone);</span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_LOGIN_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        UserPasswordDO userPasswordDO = userPasswordDOMapper.selectByUserId(userDO.getId());</span><br><span class="line"></span><br><span class="line">        UserModel userModel = convertFromDataObject(userDO,userPasswordDO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比用户信息内加密的密码是否和传输进来的密码相匹配</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.equals(encrptPassword,userPasswordDO.getEncriptPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_LOGIN_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userModel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-9-优化校验规则"><a href="#2-9-优化校验规则" class="headerlink" title="2.9 优化校验规则"></a>2.9 优化校验规则</h2><h3 id="1-引入hibernate库"><a href="#1-引入hibernate库" class="headerlink" title="1. 引入hibernate库"></a>1. 引入hibernate库</h3><p>引入hibernate库来实现validator方法  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--校验--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.4.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建validator文件夹目录  </p><h3 id="2-新建ValidationResult类返回校验结果集"><a href="#2-新建ValidationResult类返回校验结果集" class="headerlink" title="2. 新建ValidationResult类返回校验结果集"></a>2. 新建ValidationResult类返回校验结果集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationResult</span> </span>&#123;</span><br><span class="line">    <span class="comment">//校验结果是否有错</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasErrors = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放错误信息的map</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; errorMsgMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasErrors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasErrors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasErrors</span><span class="params">(<span class="keyword">boolean</span> hasErrors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasErrors = hasErrors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getErrorMsgMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMsgMap</span><span class="params">(Map&lt;String, String&gt; errorMsgMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsgMap = errorMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现通用的通过格式化字符串信息获取错误结果的msg方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.join(errorMsgMap.values().toArray(), <span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-新建ValidatorImpl实现类"><a href="#3-新建ValidatorImpl实现类" class="headerlink" title="3. 新建ValidatorImpl实现类"></a>3. 新建ValidatorImpl实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorImpl</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现校验方法并返回校验结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValidationResult <span class="title">validate</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ValidationResult result = <span class="keyword">new</span> ValidationResult();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; constraintViolationSet = validator.validate(bean);</span><br><span class="line">        <span class="keyword">if</span> (constraintViolationSet.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有错误</span></span><br><span class="line">            result.setHasErrors(<span class="keyword">true</span>);</span><br><span class="line">            constraintViolationSet.forEach(constraintViolation -&gt;&#123;</span><br><span class="line">                String errMsg = constraintViolation.getMessage();</span><br><span class="line">                String propertyName = constraintViolation.getPropertyPath().toString();</span><br><span class="line">                result.getErrorMsgMap().put(propertyName, errMsg);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将hibernate validator通过工厂的初始化方式使其实例化</span></span><br><span class="line">        <span class="keyword">this</span>.validator = Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此以后校验模型model属性时加上相应的注解即可</p>]]></content>
      
      
      <categories>
          
          <category> JavaEE部分 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot构建电商秒杀项目(一) 基础项目的搭建</title>
      <link href="/posts/a2581b07.html"/>
      <url>/posts/a2581b07.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-1-电商秒杀项目介绍"><a href="#1-1-电商秒杀项目介绍" class="headerlink" title="1.1 电商秒杀项目介绍"></a>1.1 电商秒杀项目介绍</h2><p>电商秒杀项目介绍</p><ul><li>商品列表页获取秒杀商品列表</li><li>进入商品详情页获取秒杀商品详情</li><li>秒杀开始后进入下单确认页下单并支付成功</li></ul><h2 id="1-2-IDEA创建maven项目"><a href="#1-2-IDEA创建maven项目" class="headerlink" title="1.2 IDEA创建maven项目"></a>1.2 IDEA创建maven项目</h2><p>以下流程为课程操作，实际也可以在IDEA进行Spring Initial快速配置SpringBoot  </p><ol><li><p>new-&gt;project-&gt;maven项目-&gt;选择maven-archetype-quickstart<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/1_01.png" alt="1_01"></p></li><li><p>新建一个resources目录，作为资源文件目录，点击右键，指定为Resource root<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/1_02.png" alt="1_02"></p></li><li><p>引入SpringBoot依赖包实现简单的Web项目  </p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在pom.xml中引入依赖，启动App，访问localhost：8080</p><h2 id="1-3-引入Mybatis"><a href="#1-3-引入Mybatis" class="headerlink" title="1.3 引入Mybatis"></a>1.3 引入Mybatis</h2><h3 id="1-修改application-properties"><a href="#1-修改application-properties" class="headerlink" title="1. 修改application.properties"></a>1. 修改application.properties</h3><p>在SpringBoot的默认配置文件application.properties可以配置数据库连接，引入Mybatis，使用druid数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#引入Mybatis</span><br><span class="line">mybatis.mapper-locations=classpath:mapping<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">#数据库配置</span></span><br><span class="line"><span class="comment">spring.datasource.name=miaosha</span></span><br><span class="line"><span class="comment">spring.datasource.url=jdbc:mysql://localhost:3306/miaosha?serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="comment">spring.datasource.username=root</span></span><br><span class="line"><span class="comment">spring.datasource.password=yourpassword</span></span><br><span class="line"><span class="comment">#使用druid数据源</span></span><br><span class="line"><span class="comment">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="comment">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h3 id="2-引入Plugin插件"><a href="#2-引入Plugin插件" class="headerlink" title="2. 引入Plugin插件"></a>2. 引入Plugin插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自动生成工具，生成数据库文件的映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.41<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>mybatis generator<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--允许移动生成的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--允许自动覆盖文件（生产环境中千万不要这样做）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">      src/main/resources/mybatis-generator.xml</span><br><span class="line">    <span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-Mybatis-generator自动生成器"><a href="#3-Mybatis-generator自动生成器" class="headerlink" title="3. Mybatis generator自动生成器"></a>3. Mybatis generator自动生成器</h3><p>Mybatis generator自动生成数据库对应的映射文件<br>引入官方配置xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"DB2Tables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/miaosha?serverTimezone=GMT%2B8"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"sxy123"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成DataObject类存放位置 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.miaoshaproject.dataobject"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成映射文件存放位置 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapping"</span>  <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成Dao类存放位置 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件的代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              type="ANNOTATIONDMAPPER"，生成Java Model和基于注解的Mapper 对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              type="MIXEDMAPPER",生成基于注解的Java Model和相应的Mapper对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              type="XMLMAPPER",生成SQLMap XML 文件和独立的Mapper接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"com.miaoshaproject.dao"</span>  <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成对应表及类名--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;table  tableName="user_info" domainObjectName="UserDO" enableCountByExample="false"</span></span><br><span class="line"><span class="comment">        enableUpdateByExample="false" enableDeleteByExample="false"</span></span><br><span class="line"><span class="comment">        enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;table  tableName="user_password" domainObjectName="UserPasswordDO" enableCountByExample="false"</span></span><br><span class="line"><span class="comment">                enableUpdateByExample="false" enableDeleteByExample="false"</span></span><br><span class="line"><span class="comment">                enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;table  tableName="item" domainObjectName="ItemDO" enableCountByExample="false"</span></span><br><span class="line"><span class="comment">                enableUpdateByExample="false" enableDeleteByExample="false"</span></span><br><span class="line"><span class="comment">                enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;table  tableName="item_stock" domainObjectName="ItemStockDO" enableCountByExample="false"</span></span><br><span class="line"><span class="comment">                enableUpdateByExample="false" enableDeleteByExample="false"</span></span><br><span class="line"><span class="comment">                enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;table  tableName="order_info" domainObjectName="OrderDO" enableCountByExample="false"</span></span><br><span class="line"><span class="comment">                enableUpdateByExample="false" enableDeleteByExample="false"</span></span><br><span class="line"><span class="comment">                enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;table  tableName="sequence_info" domainObjectName="SequenceDO" enableCountByExample="false"</span></span><br><span class="line"><span class="comment">                enableUpdateByExample="false" enableDeleteByExample="false"</span></span><br><span class="line"><span class="comment">                enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>  <span class="attr">tableName</span>=<span class="string">"promo"</span> <span class="attr">domainObjectName</span>=<span class="string">"PromoDO"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span> <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaEE部分 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot构建电商秒杀项目(五)秒杀模块开发</title>
      <link href="/posts/297e61d6.html"/>
      <url>/posts/297e61d6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第五章-秒杀模块开发"><a href="#第五章-秒杀模块开发" class="headerlink" title="第五章 秒杀模块开发"></a>第五章 秒杀模块开发</h1><h2 id="5-1-秒杀模型管理——活动模型创建"><a href="#5-1-秒杀模型管理——活动模型创建" class="headerlink" title="5.1 秒杀模型管理——活动模型创建"></a>5.1 秒杀模型管理——活动模型创建</h2><h3 id="1-安装joda-time依赖"><a href="#1-安装joda-time依赖" class="headerlink" title="1. 安装joda-time依赖"></a>1. 安装joda-time依赖</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>可以创建DateTime类</p><h3 id="2-创建PromoModel秒杀模型"><a href="#2-创建PromoModel秒杀模型" class="headerlink" title="2. 创建PromoModel秒杀模型"></a>2. 创建PromoModel秒杀模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromoModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀活动状态：1表示还未开始，2表示正在进行，3表示已结束</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//秒杀活动名称</span></span><br><span class="line">    <span class="keyword">private</span> String promoName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀活动的开始时间</span></span><br><span class="line">    <span class="keyword">private</span> DateTime startDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀活动的结束时间</span></span><br><span class="line">    <span class="keyword">private</span> DateTime endDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀活动的适用商品</span></span><br><span class="line">    <span class="keyword">private</span> Integer itemId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀活动的商品价格</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal promoItemPrice;</span><br></pre></td></tr></table></figure><h3 id="3-数据库创建promo表"><a href="#3-数据库创建promo表" class="headerlink" title="3. 数据库创建promo表"></a>3. 数据库创建promo表</h3><table><thead><tr><th align="center">名</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center">秒杀活动id</td></tr><tr><td align="center">promo_name</td><td align="center">varchar</td><td align="center">秒杀活动名称</td></tr><tr><td align="center">start_date</td><td align="center">datetime</td><td align="center">秒杀活动开始时间</td></tr><tr><td align="center">end_date</td><td align="center">datetime</td><td align="center">秒杀活动结束时间</td></tr><tr><td align="center">item_id</td><td align="center">int</td><td align="center">秒杀活动适用商品</td></tr><tr><td align="center">promo_item_price</td><td align="center">double</td><td align="center">秒杀活动商品价格</td></tr></tbody></table><p>注意：数据库datetime默认值要设置为’<strong>0000-00-00 00:00:00</strong>‘格式  </p><h3 id="4-mybatis-generator工具生成PromoDO类和PromoDOMapper"><a href="#4-mybatis-generator工具生成PromoDO类和PromoDOMapper" class="headerlink" title="4. mybatis-generator工具生成PromoDO类和PromoDOMapper"></a>4. mybatis-generator工具生成PromoDO类和PromoDOMapper</h3><p>运行 <strong>mvn mybatis-generator:generate</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>  <span class="attr">tableName</span>=<span class="string">"promo"</span> <span class="attr">domainObjectName</span>=<span class="string">"PromoDO"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span> <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-2-秒杀模型管理——活动模型与商品模型结合"><a href="#5-2-秒杀模型管理——活动模型与商品模型结合" class="headerlink" title="5.2 秒杀模型管理——活动模型与商品模型结合"></a>5.2 秒杀模型管理——活动模型与商品模型结合</h2><h3 id="1-Service层创建PromoSerice接口与实现类"><a href="#1-Service层创建PromoSerice接口与实现类" class="headerlink" title="1. Service层创建PromoSerice接口与实现类"></a>1. Service层创建PromoSerice接口与实现类</h3><p>秒杀活动service层主要的操作是：</p><ul><li>根据itemId来获取即将进行的或正在进行的秒杀活动信息(<strong>返回PromoDO的dataObject</strong>)</li><li>将PromoDO转化为PromoModel</li><li>根据status来判断当前时间是否即将开始或正在进行秒杀活动</li><li>返回promoModel对象</li></ul><p>PromoService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据itemId获取即将进行的或者正在进行的秒杀活动</span></span><br><span class="line">    <span class="function">PromoModel <span class="title">getPromoByItemId</span><span class="params">(Integer itemId)</span></span>;</span><br></pre></td></tr></table></figure><p>PromoService实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromoServiceImpl</span> <span class="keyword">implements</span> <span class="title">PromoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PromoDOMapper promoDOMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PromoModel <span class="title">getPromoByItemId</span><span class="params">(Integer itemId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取对应商品的秒杀活动信息</span></span><br><span class="line">        PromoDO promoDO = promoDOMapper.selectByItemId(itemId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//promoDo(dataObject) -&gt; PromoModel</span></span><br><span class="line">        PromoModel promoModel = convertFromDataObject(promoDO);</span><br><span class="line">        <span class="keyword">if</span>(promoModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前时间是否秒杀活动即将开始或正在进行</span></span><br><span class="line">        DateTime now = <span class="keyword">new</span> DateTime();</span><br><span class="line">        <span class="keyword">if</span>(promoModel.getStartDate().isAfterNow()) &#123;</span><br><span class="line">            promoModel.setStatus(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(promoModel.getEndDate().isBeforeNow()) &#123;</span><br><span class="line">            promoModel.setStatus(<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            promoModel.setStatus(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> promoModel ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> PromoModel <span class="title">convertFromDataObject</span><span class="params">(PromoDO promoDO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(promoDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PromoModel promoModel = <span class="keyword">new</span> PromoModel();</span><br><span class="line">        BeanUtils.copyProperties(promoDO,promoModel);</span><br><span class="line">        <span class="comment">//copyProperties后漏掉的属性</span></span><br><span class="line">        promoModel.setPromoItemPrice(<span class="keyword">new</span> BigDecimal(promoDO.getPromoItemPrice()));<span class="comment">//数据库存的是double类型</span></span><br><span class="line">        promoModel.setStartDate(<span class="keyword">new</span> DateTime(promoDO.getStartDate()));</span><br><span class="line">        promoModel.setEndDate(<span class="keyword">new</span> DateTime(promoDO.getEndDate()));</span><br><span class="line">        <span class="keyword">return</span> promoModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用聚合模型，在ItemModel嵌套秒杀活动属性"><a href="#2-使用聚合模型，在ItemModel嵌套秒杀活动属性" class="headerlink" title="2. 使用聚合模型，在ItemModel嵌套秒杀活动属性"></a>2. 使用聚合模型，在ItemModel嵌套秒杀活动属性</h3><p>ItemModel中加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用聚合模型（Java类嵌套），如果promoModel不为空，则表示其拥有还未结束的秒杀活动</span></span><br><span class="line"><span class="keyword">private</span> PromoModel promoModel;</span><br></pre></td></tr></table></figure><p>ItemServiceImpl加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ItemModel <span class="title">getItemById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    ItemDO itemDO = itemDOMapper.selectByPrimaryKey(id);</span><br><span class="line">    <span class="keyword">if</span> (itemDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//操作获得库存数量</span></span><br><span class="line">    ItemStockDO itemStockDO = itemStockDOMapper.selectByItemId(itemDO.getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将dataobject-&gt; Model</span></span><br><span class="line">    ItemModel itemModel = convertModelFromDataObject(itemDO, itemStockDO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取活动商品信息</span></span><br><span class="line">    PromoModel promoModel = promoService.getPromoByItemId(itemModel.getId());</span><br><span class="line">    <span class="keyword">if</span> (promoModel != <span class="keyword">null</span> &amp;&amp; promoModel.getStatus().intValue() != <span class="number">3</span>) &#123;</span><br><span class="line">        itemModel.setPromoModel(promoModel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> itemModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ItemVO中扩展秒杀活动的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录商品是否在秒杀活动中，以及对应的状态 0表示没有秒杀活动，1表示秒杀活动待开始，2表示秒杀活动进行中</span></span><br><span class="line">    <span class="keyword">private</span> Integer promoStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀活动价格</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal promoPrice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀活动ID</span></span><br><span class="line">    <span class="keyword">private</span> Integer promoId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀活动开始时间</span></span><br><span class="line">    <span class="keyword">private</span> String startDate;</span><br></pre></td></tr></table></figure><p>在ItemController中向itemVO增加秒杀活动信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ItemVO <span class="title">convertVOFromModel</span><span class="params">(ItemModel itemModel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(itemModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     ItemVO itemVO = <span class="keyword">new</span> ItemVO();</span><br><span class="line">     BeanUtils.copyProperties(itemModel,itemVO);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(itemModel.getPromoModel()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//有正在进行或即将进行的秒杀活动</span></span><br><span class="line">         itemVO.setPromoStatus(itemModel.getPromoModel().getStatus());</span><br><span class="line">         itemVO.setPromoId(itemModel.getPromoModel().getId());</span><br><span class="line">         itemVO.setStartDate(itemModel.getPromoModel().getStartDate().toString(DateTimeFormat.forPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">         itemVO.setPromoPrice(itemModel.getPromoModel().getPromoItemPrice());</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         itemVO.setPromoStatus(<span class="number">3</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> itemVO;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-修改商品详情getItem前端页面"><a href="#3-修改商品详情getItem前端页面" class="headerlink" title="3.修改商品详情getItem前端页面"></a>3.修改商品详情getItem前端页面</h3><p>增加秒杀活动状态、时间、秒杀价格以及倒计时的显示</p><h3 id="4-修改秒杀下单OrderModel部分"><a href="#4-修改秒杀下单OrderModel部分" class="headerlink" title="4.修改秒杀下单OrderModel部分"></a>4.修改秒杀下单OrderModel部分</h3><p>在OrderModel中增加秒杀价格字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若非空，则表示是以秒杀商品方式下单</span></span><br><span class="line"><span class="keyword">private</span> Integer promoId;</span><br><span class="line"></span><br><span class="line"><span class="comment">//购买时商品的单价,若promoId非空，则表示是以秒杀商品方式下单</span></span><br><span class="line"><span class="keyword">private</span> BigDecimal itemPrice;</span><br></pre></td></tr></table></figure><p>同步的在数据库order_info表加入promo_id字段，OrderDO与OrderDOMapper中加入PromoId字段</p><h3 id="5-修改秒杀下单OrderService部分"><a href="#5-修改秒杀下单OrderService部分" class="headerlink" title="5.修改秒杀下单OrderService部分"></a>5.修改秒杀下单OrderService部分</h3><p>在OrderService接口中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过url上传过来秒杀活动id，然后下单接口内校验对应id是否属于对应商品且活动已开始</span></span><br><span class="line"><span class="comment">//2.直接在下单接口内判断对应的商品是否存在秒杀活动，若存在进行中的则以秒杀价格下单</span></span><br><span class="line"><span class="comment">//倾向于使用第一种形式，因为对同一个商品可能存在不同的秒杀活动，而且第二种方案普通销售的商品也需要校验秒杀</span></span><br><span class="line"><span class="function">OrderModel <span class="title">createOrder</span><span class="params">(Integer userId, Integer itemId, Integer promoId, Integer amount)</span> <span class="keyword">throws</span> BusinessException</span>;</span><br></pre></td></tr></table></figure><p>在OrderServiceImpl中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//校验活动信息</span></span><br><span class="line">        <span class="keyword">if</span>(promoId!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//(1)校验对应活动是否存在在这个适用商品</span></span><br><span class="line">            <span class="keyword">if</span>(promoId.intValue()!=itemModel.getPromoModel().getId()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"活动信息不正常"</span>);</span><br><span class="line">            <span class="comment">//(2)校验活动是否正在进行中</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(itemModel.getPromoModel().getStatus().intValue()!=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"活动信息还未开始"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.落单减库存（还有一种：支付减库存（先支付成功，再看库存量）</span></span><br><span class="line">        <span class="keyword">boolean</span> result = itemService.decreaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.STOCK_NOT_ENOUGH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.订单入库</span></span><br><span class="line">        OrderModel orderModel = <span class="keyword">new</span> OrderModel();</span><br><span class="line">        orderModel.setUserId(userId);</span><br><span class="line">        orderModel.setItemId(itemId);</span><br><span class="line">        orderModel.setAmount(amount);</span><br><span class="line">        orderModel.setPromoId(promoId);</span><br><span class="line">        <span class="comment">//是秒杀活动，价格为秒杀价格，否则为平销价格</span></span><br><span class="line">        <span class="keyword">if</span>(promoId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            orderModel.setItemPrice(itemModel.getPromoModel().getPromoItemPrice());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            orderModel.setItemPrice(itemModel.getPrice());</span><br><span class="line">        &#125;</span><br><span class="line">        orderModel.setOrderPrice(orderModel.getItemPrice().multiply(<span class="keyword">new</span> BigDecimal(amount)));</span><br></pre></td></tr></table></figure><h3 id="6-修改秒杀下单OrderController部分"><a href="#6-修改秒杀下单OrderController部分" class="headerlink" title="6.修改秒杀下单OrderController部分"></a>6.修改秒杀下单OrderController部分</h3><p>在controller层增加参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam</span>(name = <span class="string">"promoId"</span>,required = <span class="keyword">false</span>) Integer promoId,</span><br></pre></td></tr></table></figure><p>修改前端页面：<br>测试——-》成功  </p><h2 id="5-3-项目总结"><a href="#5-3-项目总结" class="headerlink" title="5.3 项目总结"></a>5.3 项目总结</h2><p><strong>到这里我们全部完成了整个项目功能的开发，这个是入门课还存在很多问题比如：</strong><br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/5_01.png" alt="5_01"></p>]]></content>
      
      
      <categories>
          
          <category> JavaEE部分 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot构建电商秒杀项目(四)交易模块开发</title>
      <link href="/posts/8a55bc02.html"/>
      <url>/posts/8a55bc02.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第四章-交易模块开发"><a href="#第四章-交易模块开发" class="headerlink" title="第四章 交易模块开发"></a>第四章 交易模块开发</h1><h2 id="4-1-交易模型管理–交易模型创建"><a href="#4-1-交易模型管理–交易模型创建" class="headerlink" title="4.1 交易模型管理–交易模型创建"></a>4.1 交易模型管理–交易模型创建</h2><h3 id="1-创建用户下单模型OrderModel"><a href="#1-创建用户下单模型OrderModel" class="headerlink" title="1. 创建用户下单模型OrderModel"></a>1. 创建用户下单模型OrderModel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户下单的交易模型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderModel</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交易单号，例如2019052100001212，使用string类型</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//购买的用户id</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//购买的商品id</span></span><br><span class="line">    <span class="keyword">private</span> Integer itemId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//购买时商品的单价</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal itemPrice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//购买数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//购买总金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal orderPrice;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数据库创建order-info表"><a href="#2-数据库创建order-info表" class="headerlink" title="2. 数据库创建order_info表"></a>2. 数据库创建order_info表</h3><table><thead><tr><th align="center">名</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">String</td><td align="center">交易号</td></tr><tr><td align="center">userId</td><td align="center">Integer</td><td align="center">购买用户id</td></tr><tr><td align="center">itemId</td><td align="center">Integer</td><td align="center">购买商品id</td></tr><tr><td align="center">itemPrice</td><td align="center">BigDecimal</td><td align="center">购买商品单价</td></tr><tr><td align="center">amount</td><td align="center">Integer</td><td align="center">购买数量</td></tr><tr><td align="center">orderPrice</td><td align="center">BigDecimal</td><td align="center">购买总金额</td></tr></tbody></table><h3 id="3-mybatis-generator生成数据库映射"><a href="#3-mybatis-generator生成数据库映射" class="headerlink" title="3. mybatis generator生成数据库映射"></a>3. mybatis generator生成数据库映射</h3><p> mybatis generator生成order_info表及OrderDO<br>运行 <strong>mvn mybatis-generator:generate</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"order_info"</span> <span class="attr">domainObjectName</span>=<span class="string">"OrderDO"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-2-交易模型管理-交易下单"><a href="#4-2-交易模型管理-交易下单" class="headerlink" title="4.2 交易模型管理-交易下单"></a>4.2 交易模型管理-交易下单</h2><h3 id="1-OrderService接口部分"><a href="#1-OrderService接口部分" class="headerlink" title="1.OrderService接口部分"></a>1.OrderService接口部分</h3><p>实现createOrder函数，通过用户id,商品id以及购买数量创建订单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OrderModel <span class="title">createOrder</span><span class="params">(Integer userId, Integer itemId, Integer amount)</span> <span class="keyword">throws</span> BusinessException</span>;</span><br></pre></td></tr></table></figure><h3 id="2-OrderServiceImpl实现类"><a href="#2-OrderServiceImpl实现类" class="headerlink" title="2.OrderServiceImpl实现类"></a>2.OrderServiceImpl实现类</h3><p>用户下单的流程主要包括：</p><ul><li>校验下单状态，包括下单商品是否存在，用户是否合法，购买数量是否正确</li><li>减少库存量(落单减库存)</li><li>订单入库</li><li>返回前端</li></ul><h4 id="1-校验下单状态"><a href="#1-校验下单状态" class="headerlink" title="1. 校验下单状态"></a>1. 校验下单状态</h4><p><strong>校验下单商品是否存在</strong>是通过商品id在itemService查询itemModel,<strong>校验用户是否合法</strong>是用userId在userService里查找userModel,<strong>校验购买数量</strong>我们规定一个用户最少购买1件最多不超过100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.校验下单状态，下单的商品是否存在，用户是否合法，购买数量是否正确</span></span><br><span class="line">   ItemModel itemModel = itemService.getItemById(itemId);</span><br><span class="line">   <span class="keyword">if</span> (itemModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, <span class="string">"商品信息不存在"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   UserModel userModel = userService.getUserById(userId);</span><br><span class="line">   <span class="keyword">if</span> (userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, <span class="string">"用户信息不存在"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (amount &lt;= <span class="number">0</span> || amount &gt; <span class="number">99</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, <span class="string">"数量信息不存在"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2-落单减库存"><a href="#2-落单减库存" class="headerlink" title="2. 落单减库存"></a>2. 落单减库存</h4><p>减少库存量有两种方式：<strong>落单减库存</strong>以及<strong>支付减库存</strong>。<br>对应的就是在用户下单成功还是支付成功后减少库存，支付成功后减库存因为支付时未加库存锁，所以会出现支付成功但因库存不够退单情况。而落单减库存则可能出现恶意刷单的情况。这里我们采取落单减库存的方式。  </p><p>ItemStockMapper增加对item_stock数据库减操作<br>ItemStockMapper.xml  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"decreaseStock"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  update item_stock</span><br><span class="line">  set stock = stock-#&#123;amount&#125;</span><br><span class="line">  where item_id = #&#123;item_id&#125; and stock&gt;=#&#123;amount&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ItemStockMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decreaseStock</span><span class="params">(@Param(<span class="string">"itemId"</span>)</span> Integer itemId, @<span class="title">Param</span><span class="params">(<span class="string">"amount"</span>)</span> Integer amount)</span>;</span><br></pre></td></tr></table></figure><p>ItemService接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;库存扣减</span><br><span class="line">    boolean decreaseStock(Integer itemId,Integer amount) throws BusinessException;</span><br></pre></td></tr></table></figure><p>ItemServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> affectedRow = itemStockDOMapper.decreaseStock(itemId, amount);</span><br><span class="line">     <span class="keyword">if</span> (affectedRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//更新库存成功</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//更新库存失败</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-生成交易订单号"><a href="#3-生成交易订单号" class="headerlink" title="3. 生成交易订单号"></a>3. 生成交易订单号</h4><p>交易订单号有16类，比如”2020031100000100”，前8位为时间信息，年月日，中间6位为自增序列,最后2位为分库分表位，我们暂时不考虑<br>前8位我们用LocalDateTime类获取当前时间并转化为<strong>ISO_DATE</strong>类型的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订单号有16位</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//前8位为时间信息，年月日</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        <span class="comment">//2020-03-08</span></span><br><span class="line">        String nowDate = now.format(DateTimeFormatter.ISO_DATE).replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">        stringBuilder.append(nowDate);</span><br></pre></td></tr></table></figure><p>中间6位为自增序列，初始值为0，我们新建一个sequence_info的数据库，每次访问要加锁，表示一个下单数  </p><p>sequ_info表</p><table><thead><tr><th align="center">名</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">String</td><td align="center">订单表</td></tr><tr><td align="center">current_value</td><td align="center">int</td><td align="center">当前订单数</td></tr><tr><td align="center">step</td><td align="center">int</td><td align="center">下单数加1</td></tr></tbody></table><p>修改mybatis-generator生成SequenceDO，SequenceDOMapper</p><p>运行 <strong>mvn mybatis-generator:generate</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"sequence_info"</span> <span class="attr">domainObjectName</span>=<span class="string">"SequenceDO"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改SequenceDOMapper.xml，自增时用<strong>for update</strong>添加行锁</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getSequenceByName"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">  from sequence_info</span><br><span class="line">  where name = #&#123;name,jdbcType=VARCHAR&#125; for update</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生成订单号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateOrderNo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//订单号有16位</span></span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//前8位为时间信息，年月日</span></span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    <span class="comment">//2020-03-08</span></span><br><span class="line">    String nowDate = now.format(DateTimeFormatter.ISO_DATE).replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">    stringBuilder.append(nowDate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中间6位为自增序列</span></span><br><span class="line">    <span class="comment">//新建sequence_info表，初始值为0，实现每次获取加一</span></span><br><span class="line">    <span class="comment">//获取当前sequence</span></span><br><span class="line">    <span class="keyword">int</span> sequence = <span class="number">0</span>;</span><br><span class="line">    SequenceDO sequenceDO = sequenceDOMapper.getSequenceByName(<span class="string">"order_info"</span>);</span><br><span class="line">    sequence = sequenceDO.getCurrentValue();</span><br><span class="line">    sequenceDO.setCurrentValue(sequenceDO.getCurrentValue() + sequenceDO.getStep());</span><br><span class="line">    sequenceDOMapper.updateByPrimaryKeySelective(sequenceDO);</span><br><span class="line">    <span class="comment">//拼足中间6位</span></span><br><span class="line">    String sequenceStr = String.valueOf(sequence);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">6</span>-sequenceStr.length();i++) &#123;</span><br><span class="line">        stringBuilder.append(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.append(sequenceStr);</span><br><span class="line">    <span class="comment">//最后2位为分库分表位,暂时写死</span></span><br><span class="line">    stringBuilder.append(<span class="string">"00"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString();</span><br></pre></td></tr></table></figure><h4 id="4-销量增加"><a href="#4-销量增加" class="headerlink" title="4. 销量增加"></a>4. 销量增加</h4><p>itemDOMapper.xml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"increaseSales"</span>&gt;</span></span><br><span class="line">  update item</span><br><span class="line">  set sales = sales+ #&#123;amount&#125;</span><br><span class="line">  where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>itemDOMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">increaseSales</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id, @<span class="title">Param</span><span class="params">(<span class="string">"amount"</span>)</span> Integer amount)</span>;</span><br></pre></td></tr></table></figure><p>ItemServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseSales</span><span class="params">(Integer itemId, Integer amount)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    itemDOMapper.increaseSales(itemId,amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-最终的OrderServiceImpl类"><a href="#5-最终的OrderServiceImpl类" class="headerlink" title="5. 最终的OrderServiceImpl类"></a>5. 最终的OrderServiceImpl类</h4><p>注解<font color="red">@Transactional</font>的作用保证事务的一致<br>下单函数createOrder中用到了<font color="red">@Transactional(propagation = Propagation.REQUIRED)</font>表示执行代码后，不管成功与否，直接提交事务。不管该方法是否在事务中，都会开启一个新的事务，<strong>为了保证订单号的唯一性，防止下单失败后订单号的回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED) <span class="comment">//propagation.REQUIRED表示执行代码后不管成功与否，直接提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderModel <span class="title">createOrder</span><span class="params">(Integer userId, Integer itemId, Integer promoId, Integer amount)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">        <span class="comment">//1.校验下单状态，下单的商品是否存在，用户是否合法，购买的数量是否正确</span></span><br><span class="line">        ItemModel itemModel = itemService.getItemById(itemId);</span><br><span class="line">        <span class="keyword">if</span>(itemModel == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"商品信息不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        UserModel userModel = userService.getUserById(userId);</span><br><span class="line">        <span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"用户信息不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt;= <span class="number">0</span> || amount &gt; <span class="number">99</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"数量信息不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验活动信息</span></span><br><span class="line">        <span class="keyword">if</span>(promoId!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//(1)校验对应活动是否存在在这个适用商品</span></span><br><span class="line">            <span class="keyword">if</span>(promoId.intValue()!=itemModel.getPromoModel().getId()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"活动信息不正常"</span>);</span><br><span class="line">            <span class="comment">//(2)校验活动是否正在进行中</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(itemModel.getPromoModel().getStatus().intValue()!=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"活动信息还未开始"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.落单减库存（还有一种：支付减库存（先支付成功，再看库存量）</span></span><br><span class="line">        <span class="keyword">boolean</span> result = itemService.decreaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.STOCK_NOT_ENOUGH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.订单入库</span></span><br><span class="line">        OrderModel orderModel = <span class="keyword">new</span> OrderModel();</span><br><span class="line">        orderModel.setUserId(userId);</span><br><span class="line">        orderModel.setItemId(itemId);</span><br><span class="line">        orderModel.setAmount(amount);</span><br><span class="line">        orderModel.setPromoId(promoId);</span><br><span class="line">        <span class="comment">//是秒杀活动，价格为秒杀价格，否则为平销价格</span></span><br><span class="line">        <span class="keyword">if</span>(promoId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            orderModel.setItemPrice(itemModel.getPromoModel().getPromoItemPrice());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            orderModel.setItemPrice(itemModel.getPrice());</span><br><span class="line">        &#125;</span><br><span class="line">        orderModel.setOrderPrice(orderModel.getItemPrice().multiply(<span class="keyword">new</span> BigDecimal(amount)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成交易流水号,订单号</span></span><br><span class="line">        orderModel.setId(generateOrderNo());</span><br><span class="line">        OrderDO orderDO = convertFromOrderModel(orderModel);</span><br><span class="line">        orderDOMapper.insertSelective(orderDO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加上商品的销量</span></span><br><span class="line">        itemService.increaseSales(itemId, amount);</span><br><span class="line">        <span class="comment">//4.返回前端</span></span><br><span class="line">        <span class="keyword">return</span> orderModel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Controller层创建下单"><a href="#3-Controller层创建下单" class="headerlink" title="3. Controller层创建下单"></a>3. Controller层创建下单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装下单请求</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/createorder"</span>, method = &#123;RequestMethod.POST&#125;, consumes = &#123;CONTENT_TYPE_FORMED&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">createOrder</span><span class="params">(@RequestParam(name = <span class="string">"itemId"</span>)</span> Integer itemId,</span></span><br><span class="line"><span class="function">                                    @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"amount"</span>)</span> Integer amount) <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取用户登录信息</span></span><br><span class="line">    Boolean isLogin = (Boolean) httpServletRequest.getSession().getAttribute(<span class="string">"IS_LOGIN"</span>);</span><br><span class="line">    <span class="keyword">if</span> (isLogin == <span class="keyword">null</span> || !isLogin.booleanValue()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_LOGIN, <span class="string">"用户还未登录，不能下单"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    UserModel userModel = (UserModel) httpServletRequest.getSession().getAttribute(<span class="string">"LOGIN_USER"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    OrderModel orderModel = orderService.createOrder(userModel.getId(), itemId, amount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-前端设计"><a href="#4-前端设计" class="headerlink" title="4. 前端设计"></a>4. 前端设计</h3>]]></content>
      
      
      <categories>
          
          <category> JavaEE部分 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot构建电商秒杀项目(三)商品模块开发</title>
      <link href="/posts/46510985.html"/>
      <url>/posts/46510985.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第三章-商品模块开发"><a href="#第三章-商品模块开发" class="headerlink" title="第三章 商品模块开发"></a>第三章 商品模块开发</h1><h2 id="3-1-商品创建"><a href="#3-1-商品创建" class="headerlink" title="3.1 商品创建"></a>3.1 商品创建</h2><p>我们在进行模块开发的过程中应遵循先设计领域模型，再设计数据库的过程。因为领域模型中经常存在有级联关系(比如商品模型与销售模型之间)，所以数据库的设计应该在领域模型设计之后。</p><h3 id="1-创建ItemModel领域模型"><a href="#1-创建ItemModel领域模型" class="headerlink" title="1.创建ItemModel领域模型"></a>1.创建ItemModel领域模型</h3><p>商品模型主要包含有商品名，价格，库存，描述信息，图片url属性。为了减少在代码上对属性的一一判空，我们采用上节课学习到的validator来判空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品价格</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品的库存</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品的描述</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品的销量</span></span><br><span class="line">    <span class="keyword">private</span> Integer sales;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品描述图片的url</span></span><br><span class="line">    <span class="keyword">private</span> String imgUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数据库表设计"><a href="#2-数据库表设计" class="headerlink" title="2. 数据库表设计"></a>2. 数据库表设计</h3><p>考虑到之后商品交易下单要用到库存属性，所以我们设计两张表item以及库存表item_stock  </p><p>item表</p><table><thead><tr><th align="center">名</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center">商品id</td></tr><tr><td align="center">title</td><td align="center">String</td><td align="center">商品名称</td></tr><tr><td align="center">price</td><td align="center">double</td><td align="center">商品价格</td></tr><tr><td align="center">descirption</td><td align="center">varchar</td><td align="center">商品描述</td></tr><tr><td align="center">sales</td><td align="center">int</td><td align="center">商品销量</td></tr><tr><td align="center">img_url</td><td align="center">varchar</td><td align="center">图片URL</td></tr></tbody></table><p>itemStock表</p><table><thead><tr><th align="center">名</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center">库存id</td></tr><tr><td align="center">stock</td><td align="center">int</td><td align="center">库存量</td></tr><tr><td align="center">item_id</td><td align="center">int</td><td align="center">商品id</td></tr></tbody></table><h3 id="3-mybatis-generator生成数据库映射"><a href="#3-mybatis-generator生成数据库映射" class="headerlink" title="3.mybatis generator生成数据库映射"></a>3.mybatis generator生成数据库映射</h3><p>运行 <strong>mvn mybatis-generator:generate</strong><br>生成ItemDO,ItemStockDO以及ItemDOMapper,ItemStockDOMapper文件  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>  <span class="attr">tableName</span>=<span class="string">"item"</span> <span class="attr">domainObjectName</span>=<span class="string">"ItemDO"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span> <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>  <span class="attr">tableName</span>=<span class="string">"item_stock"</span> <span class="attr">domainObjectName</span>=<span class="string">"ItemStockDO"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span> <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于在数据库设计过程中，我们让id属性采取自增的方式，所以要修改<strong>ItemDOMapper.xml</strong>与<strong>ItemStockDOMapper.xml</strong>所有的Insert和InsertSelective操作，向其中添加属性<strong>useGeneratedKeys=”true” keyProperty=”id”</strong>  </p><h3 id="4-Serivice层部分"><a href="#4-Serivice层部分" class="headerlink" title="4. Serivice层部分"></a>4. Serivice层部分</h3><p>商品模块的部分主要要实现的功能是：</p><ul><li>创建商品</li><li>浏览商品</li><li>商品详情浏览</li></ul><p>ItemService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建商品</span></span><br><span class="line">    <span class="function">ItemModel <span class="title">createItem</span><span class="params">(ItemModel itemModel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品列表浏览</span></span><br><span class="line">    <span class="function">List&lt;ItemModel&gt; <span class="title">listItem</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品详情浏览</span></span><br><span class="line">    <span class="function">ItemModel <span class="title">getItemById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ItemServiceImpl实现类<br>首先我们为了节省对模型属性的判空校验，采用validator来对数据入参校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//商品名称</span></span><br><span class="line"><span class="meta">@NotBlank</span>(message = <span class="string">"商品名称不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line"><span class="comment">//商品价格</span></span><br><span class="line"><span class="meta">@NotNull</span>(message = <span class="string">"商品价格不能为空"</span>)</span><br><span class="line"><span class="meta">@Min</span>(value = <span class="number">0</span>,message = <span class="string">"商品价格必须大于0"</span>)</span><br><span class="line"><span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line"><span class="comment">//商品的库存</span></span><br><span class="line"><span class="meta">@NotNull</span>(message = <span class="string">"库存不能不填"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer stock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//商品的描述</span></span><br><span class="line"><span class="meta">@NotBlank</span>(message = <span class="string">"商品描述信息不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line"><span class="comment">//商品的销量</span></span><br><span class="line"><span class="meta">@NotBlank</span>(message = <span class="string">"商品图片信息不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">//商品描述图片的url</span></span><br><span class="line"><span class="keyword">private</span> String imgUrl;</span><br></pre></td></tr></table></figure><h4 id="1-创建商品"><a href="#1-创建商品" class="headerlink" title="1. 创建商品"></a>1. 创建商品</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//在同一事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ItemModel <span class="title">createItem</span><span class="params">(ItemModel itemModel)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="comment">//校验入参</span></span><br><span class="line">    ValidationResult result = validator.validate(itemModel);</span><br><span class="line">    <span class="keyword">if</span>(result.isHasErrors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,result.getErrMsg());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换ItemModel-&gt;dataobject</span></span><br><span class="line">    ItemDO itemDO = <span class="keyword">this</span>.convertItemDOFromItemModel(itemModel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入数据库</span></span><br><span class="line">    itemDOMapper.insertSelective(itemDO);</span><br><span class="line">    itemModel.setId(itemDO.getId());</span><br><span class="line"></span><br><span class="line">    ItemStockDO itemStockDO = <span class="keyword">this</span>.convertItemStockDOFromItemModel(itemModel);</span><br><span class="line"></span><br><span class="line">    itemStockDOMapper.insertSelective(itemStockDO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回创建完成的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getItemById(itemModel.getId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ItemModel-&gt;dataobject(ItemStockDO)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ItemStockDO <span class="title">convertItemStockDOFromItemModel</span><span class="params">(ItemModel itemModel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(itemModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ItemStockDO itemStockDO = <span class="keyword">new</span> ItemStockDO();</span><br><span class="line">    itemStockDO.setItemId(itemModel.getId());</span><br><span class="line">    itemStockDO.setStock(itemModel.getStock());</span><br><span class="line">    <span class="keyword">return</span> itemStockDO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ItemModel-&gt;dataObject(ItemDO)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ItemDO <span class="title">convertItemDOFromItemModel</span><span class="params">(ItemModel itemModel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(itemModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ItemDO itemDO = <span class="keyword">new</span> ItemDO();</span><br><span class="line">    BeanUtils.copyProperties(itemModel,itemDO);</span><br><span class="line">    <span class="comment">//将ItemModel里price类型BigDecimal转换为Double</span></span><br><span class="line">    itemDO.setPrice(itemModel.getPrice().doubleValue());</span><br><span class="line">    <span class="keyword">return</span> itemDO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-浏览商品"><a href="#2-浏览商品" class="headerlink" title="2. 浏览商品"></a>2. 浏览商品</h4><p>浏览商品我们这里简单的设计成向数据库查找所有商品的信息，存在list中然后在首页显示  </p><p>itemDOMapper.xml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listItem"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">  from item order by sales DESC</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>itemDOMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现ItemDOMapper.xml中listItem方法</span></span><br><span class="line"><span class="function">List&lt;ItemDO&gt; <span class="title">listItem</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>ItemServiceImpl<br>我们定义好了数据库操作后获得的是List<ItemDO>形式，要用到<font color="red">java8特性Lambda表达式</font>的方式将其转化为List<ItemModel>的方式</ItemModel></ItemDO></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//商品列表</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ItemModel&gt; <span class="title">listItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ItemDO&gt; itemDOList = itemDOMapper.listItem();</span><br><span class="line">        <span class="comment">//java8 streamAPI将itemDO map成itemModel</span></span><br><span class="line">        <span class="comment">//再使用collect(Collectors.toList())转化成list</span></span><br><span class="line">        List&lt;ItemModel&gt; itemModelList =itemDOList.stream().map(itemDO -&gt; &#123;</span><br><span class="line">            ItemStockDO itemStockDO = itemStockDOMapper.selectByItemId(itemDO.getId());</span><br><span class="line">            ItemModel itemModel = <span class="keyword">this</span>.convertModelFromDataObject(itemDO,itemStockDO);</span><br><span class="line">            <span class="keyword">return</span> itemModel;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> itemModelList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-商品详情浏览"><a href="#3-商品详情浏览" class="headerlink" title="3. 商品详情浏览"></a>3. 商品详情浏览</h4><p>商品详情浏览的设计应该是通过商品id分别向商品表和库存表中查询对应的dataObject(ItemDO与ItemStockDO),然后经过整合函数convertModelFromDataObject将它们转化成itemModel  </p><p>ItemServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ItemModel <span class="title">getItemById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        ItemDO itemDO = itemDOMapper.selectByPrimaryKey(id);</span><br><span class="line">        <span class="keyword">if</span> (itemDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//操作获得库存数量</span></span><br><span class="line">        ItemStockDO itemStockDO = itemStockDOMapper.selectByItemId(itemDO.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将dataobject-&gt; Model</span></span><br><span class="line">        ItemModel itemModel = convertModelFromDataObject(itemDO, itemStockDO);</span><br><span class="line">        <span class="keyword">return</span> itemModel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ItemModel <span class="title">convertModelFromDataObject</span><span class="params">(ItemDO itemDO,ItemStockDO itemStockDO)</span> </span>&#123;</span><br><span class="line">        ItemModel itemModel = <span class="keyword">new</span> ItemModel();</span><br><span class="line">        BeanUtils.copyProperties(itemDO,itemModel);</span><br><span class="line">        itemModel.setPrice(<span class="keyword">new</span> BigDecimal(itemDO.getPrice()));</span><br><span class="line">        itemModel.setStock(itemStockDO.getStock());</span><br><span class="line">        <span class="keyword">return</span> itemModel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-Controller部分"><a href="#5-Controller部分" class="headerlink" title="5. Controller部分"></a>5. Controller部分</h3><h4 id="1-创建商品部分"><a href="#1-创建商品部分" class="headerlink" title="1.创建商品部分"></a>1.创建商品部分</h4><p>对于创建商品部分，传入的参数包括title,description,price,stock,imgUrl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建商品的controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/create"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">createItem</span><span class="params">(@RequestParam(name = <span class="string">"title"</span>)</span> String title,</span></span><br><span class="line"><span class="function">                                   @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"description"</span>)</span> String description,</span></span><br><span class="line"><span class="function">                                   @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"price"</span>)</span> BigDecimal price,</span></span><br><span class="line"><span class="function">                                   @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"stock"</span>)</span> Integer stock,</span></span><br><span class="line"><span class="function">                                   @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"imgUrl"</span>)</span> String imgUrl) <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line"><span class="comment">//封装service请求用来创建商品</span></span><br><span class="line">    ItemModel itemModel = <span class="keyword">new</span> ItemModel();</span><br><span class="line">    itemModel.setTitle(title);</span><br><span class="line">    itemModel.setStock(stock);</span><br><span class="line">    itemModel.setDescription(description);</span><br><span class="line">    itemModel.setPrice(price);</span><br><span class="line">    itemModel.setImgUrl(imgUrl);</span><br><span class="line"></span><br><span class="line">    ItemModel itemModelForReturn = itemService.createItem(itemModel);</span><br><span class="line">    ItemVO itemVO = <span class="keyword">this</span>.convertVOFromModel(itemModelForReturn);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//itemModel -&gt; itemVO</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ItemVO <span class="title">convertVOFromModel</span><span class="params">(ItemModel itemModel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(itemModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     ItemVO itemVO = <span class="keyword">new</span> ItemVO();</span><br><span class="line">     BeanUtils.copyProperties(itemModel,itemVO);</span><br><span class="line">     <span class="keyword">return</span> itemVO;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于我们不想让包含全部属性的itemModel传入前端，所以要另外设计一层视图类ItemVO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemVO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品价格</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品库存</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品的描述</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品的销量</span></span><br><span class="line">    <span class="keyword">private</span> Integer sales;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品描述图片的url</span></span><br><span class="line">    <span class="keyword">private</span> String imgUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-商品列表页面浏览"><a href="#2-商品列表页面浏览" class="headerlink" title="2. 商品列表页面浏览"></a>2. 商品列表页面浏览</h4><p>商品列表页面浏览<br>同样用到了<strong>java8 Lambda表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//商品列表页面浏览</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/list"</span>,method = RequestMethod.GET) <span class="comment">//浏览时服务端用GET请求</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">listItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;ItemModel&gt; itemModelList = itemService.listItem();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//java8 使用stream()API 将List内的itemModel map转化成itemVO</span></span><br><span class="line">       List&lt;ItemVO&gt; itemVOList = itemModelList.stream().map(itemModel -&gt; &#123;</span><br><span class="line">           ItemVO itemVO = <span class="keyword">this</span>.convertVOFromModel(itemModel);</span><br><span class="line">           <span class="keyword">return</span> itemVO;</span><br><span class="line">       &#125;).collect(Collectors.toList());</span><br><span class="line">       <span class="keyword">return</span> CommonReturnType.create(itemVOList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-商品详情页面浏览"><a href="#3-商品详情页面浏览" class="headerlink" title="3. 商品详情页面浏览"></a>3. 商品详情页面浏览</h4><p>商品详情浏览传入的参数是id,用GET请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//商品详情页浏览</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>,method = RequestMethod.GET) <span class="comment">//浏览时服务端用GET请求</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        ItemModel itemModel = itemService.getItemById(id);</span><br><span class="line"></span><br><span class="line">        ItemVO itemVO = <span class="keyword">this</span>.convertVOFromModel(itemModel);</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="6-前端设计"><a href="#6-前端设计" class="headerlink" title="6.前端设计"></a>6.前端设计</h3>]]></content>
      
      
      <categories>
          
          <category> JavaEE部分 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode17 电话号码组合</title>
      <link href="/posts/ef60d55f.html"/>
      <url>/posts/ef60d55f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/17_01.png" alt="17_01"></p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>输入： “23”<br>  输出: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>&emsp;看到题目描述，应该想到用回溯法。回溯是一种通过穷举所有可能情况里找到<strong>所有解</strong>的算法。如果发现一种候选解不可行，则会舍弃它，并重新寻找可行解。几个注意的地方：  </p><ol><li>一个数字对应一个字符串，想到用HashMap存储</li><li>递归的终止条件是下一个数字输入为空</li><li>递归的顺序应该是遍历每个数字，再遍历每个对应的所有映射字母。每一种情况应该是遍历数字后字符之间的加和，如示例里面的”ad”。</li></ol><p>&emsp;给出回溯函数<strong>combination(String results, String next_digits)</strong>,<strong>results</strong>表示当前已经产生的组合，<strong>next_digits</strong>表示接下来要输入的数字<br>如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。<br>&emsp;如果还有数字需要被输入：<br>输入数字是phone.get(nex_digits).substring(0,1)<br>遍历下一个数字所对应的所有映射的字母。<br>将当前的字母添加到组合最后，也就是 results = results + s 。<br>&emsp;重复这个过程，输入剩下的数字： combination(results + s, next_digits[1:]) 。</p><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/17_02.png" alt="17_02"></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; phone = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        put(<span class="string">"2"</span>, <span class="string">"abc"</span>);</span><br><span class="line">        put(<span class="string">"3"</span>, <span class="string">"def"</span>);</span><br><span class="line">        put(<span class="string">"4"</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        put(<span class="string">"5"</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        put(<span class="string">"6"</span>, <span class="string">"mno"</span>);</span><br><span class="line">        put(<span class="string">"7"</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        put(<span class="string">"8"</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        put(<span class="string">"9"</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给定初始条件</span></span><br><span class="line">    <span class="keyword">if</span>(digits.length()!=<span class="number">0</span>) &#123;</span><br><span class="line">        combination(<span class="string">""</span>,digits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存最后所有情况</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combination</span><span class="params">(String results, String next_digits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下一个数字为空，递归终止</span></span><br><span class="line">    <span class="keyword">if</span> (next_digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        output.add(results);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String str = phone.get(next_digits);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            String s = str.substring(i,i+<span class="number">1</span>);</span><br><span class="line">            combination(results+s,next_digits.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><strong>时间复杂度</strong>： O(3^N x 4^M)<br>其中 N 是输入数字中对应 3 个字母的数目（比方说 2，3，4，5，6，8）， M 是输入数字中对应 4 个字母的数目（比方说 7，9），N+M 是输入数字的总数。<br><strong>空间复杂度</strong>： O(3^N x 4^M)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode22括号生成</title>
      <link href="/posts/ce637d7c.html"/>
      <url>/posts/ce637d7c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：  </p><blockquote><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]  </p></blockquote><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><h2 id="方法一-暴力法"><a href="#方法一-暴力法" class="headerlink" title="方法一 暴力法"></a>方法一 暴力法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力法是我当时的思路，就是生成所有可能的组合然后再判断是否符合条件。 </p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>生成所有的组合方法是<strong>回溯法</strong>，总共有2^(2n)种结果。<br>判断是否符合格式用堆栈的方法，将左括号入栈，当遇到右括号时将栈顶的左括号弹出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    generateAll(<span class="string">""</span>,<span class="number">0</span>,n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateAll</span><span class="params">(String str, <span class="keyword">int</span> current,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current == n*<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isAvaible(str)) &#123;</span><br><span class="line">            result.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        generateAll(str+<span class="string">"("</span>,current+<span class="number">1</span>,n);</span><br><span class="line">        generateAll(str+<span class="string">")"</span>,current+<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvaible</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            stack.push(str.charAt(i));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.peek().equals(str.charAt(i))) &#123;</span><br><span class="line">            stack.push(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.peek() == <span class="string">'('</span> &amp;&amp; str.charAt(i) == <span class="string">')'</span></span><br><span class="line">                ) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度O（2^(2n)<em>n） 总共有2^(2n)个序列，验证每一个需要O（n）<br>空间复杂度O(2^(2n)</em>n)<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/22_01.png" alt></p><h2 id="方法二-深度优先遍历-剪枝"><a href="#方法二-深度优先遍历-剪枝" class="headerlink" title="方法二 深度优先遍历 + 剪枝"></a>方法二 深度优先遍历 + 剪枝</h2><p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/22_02.png" alt><br>利用深度优先遍历的方法生成树，并且不满足的进行剪枝</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ol><li>当前左右括号个数都大于0时可以产生分支</li><li>产生左分支的条件是，还有左括号可使用</li><li>产生右分支的条件是，左括号可使用的数量大于右括号数量</li><li>当左右剩余括号的数量都为0时就是一种结果<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    dfs(res,<span class="string">""</span>,n,n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt;res, String curStr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止后，将字符串添加到结果集</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(curStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剪枝情况:左括号可使用的数量大于右括号</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//左括号生枝条件</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(res,curStr+<span class="string">"("</span>,left-<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(res,curStr+<span class="string">")"</span>,left,right-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n^2)<br>空间复杂度：O(n)<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/22_03.png" alt></p><h2 id="方法三-动态规划法"><a href="#方法三-动态规划法" class="headerlink" title="方法三 动态规划法"></a>方法三 动态规划法</h2><p>这道题用动态规划法效果一般，可提供一种思路。就是将第i种有效括号组合等价成 “(“ + 可能的括号对数 + “)” + 剩余的括号对数</p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>第 1 步：定义状态</strong>  dp[i]：使用 i 对括号能够生成的组合。</p><p><strong>注意</strong>：每一个状态都是列表的形式。</p><p><strong>第 2 步：状态转移方程：</strong></p><ul><li>i 对括号的一个组合，在 i - 1 对括号的基础上得到，这是思考 “状态转移方程” 的基础；</li><li>i 对括号的一个组合，一定以左括号 “(“ 开始，不一定以 “)” 结尾。为此，我们可以枚举新的右括号 “)” 可能所处的位置，得到所有的组合；</li><li>枚举的方式就是枚举左括号 “(“ 和右括号 “)” <strong>中间可能的合法的括号对数</strong>，而剩下的合法的括号对数在与第一个左括号 “(“ 配对的右括号 “)” 的后面，这就用到了以前的状态。<br>状态转移方程是：</li></ul><blockquote><p>dp[i] = <font color="red">“(“ </font> + dp[可能的括号对数] + <font color="red">“)”</font> + dp[剩下的括号对数]</p></blockquote><ul><li>可能的括号对数从0开始到i-1</li><li>剩下的括号对数 + j = i -1 ,所以是 i-j-1  </li></ul><blockquote><p>dp[i] = “(“ + dp[j] + “)” + dp[i- j - 1] , j = 0, 1, …, i - 1 </p></blockquote><p><strong>第 3 步： 思考初始状态和输出:</strong></p><ul><li>初始状态：因为我们需要 0 对括号这种状态，因此状态数组 dp 从 0 开始，0 个括号当然就是 [“”]。</li><li>输出：dp[n] 。  </li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//dp[]数组 初始化为动态数组</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; dp = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="comment">//dp0</span></span><br><span class="line">        List&lt;String&gt; dp0 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dp0.add(<span class="string">""</span>);</span><br><span class="line">        dp.add(dp0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            List&lt;String&gt; dpi = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                List&lt;String&gt; dp_j = dp.get(j);</span><br><span class="line">                List&lt;String&gt; dp_i_j = dp.get(i-j-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//dp[i] = ( + dp[j] + ) + dp[i-j-1]</span></span><br><span class="line">                <span class="keyword">for</span> (String s1 : dp_j) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String s2 : dp_i_j) &#123;</span><br><span class="line">                        dpi.add(<span class="string">"("</span> + s1 + <span class="string">")"</span> + s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.add(dpi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.get(n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n^4)<br>空间复杂度：O(n)<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/22_04.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode19删除链表倒数第N个节点</title>
      <link href="/posts/30fb160e.html"/>
      <url>/posts/30fb160e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：  </p><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.  </p></blockquote><p>&emsp;试用一趟遍历实现</p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>&emsp;这个问题可以简化为：删除从列表开始的第(L-n+1)个结点，其中L是列表的长度，找到列表长度L，问题就很容易解决。  </p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>&emsp;首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)个结点那里。我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)(L?n+2) 个结点，完成这个算法<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/19_01.jpg" alt="19_01"> </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">int</span> length  = <span class="number">0</span>;</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    length -= n;</span><br><span class="line">    first = dummy;</span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        length--;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    first.next = first.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>&emsp;联想到一道寻找链表第k个结点的数那道题，我们可以用双指针法来解决。为了处理只存在一个结点或其他与头结点有关的操作的情况，选择插入一个<strong>哑结点</strong>。因为题目是倒数第n个节点，我们先让第一个结点向前走n+1步，然后这时第二个结点再与第一个结点同步（两个结点之间有n个数），当快指针走到尽头时，慢指针在要删除结点的前面。<br><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/19_02.jpg" alt="19_02"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode first = dummy;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="comment">// Advances first pointer so that the gap between first and second is n nodes apart</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move first to the end, maintaining the gap</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度O(L)&emsp;<br>空间复杂度O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
