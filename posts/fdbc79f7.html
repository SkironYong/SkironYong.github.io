<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>十二种排序总结(快排、归并、希尔、计数排序等) | SkironYong</title><meta name="description" content="前言排序算法在计算机科学入门课程中很普遍，在学习排序算法的时候，涉及到大量的各种核心算法概念，例如大O表示法，分治法，堆和二叉树之类的数据结构，随机算法，最佳、最差和平均情况分析，时空权衡以及上限和下限，本文就介绍了十二种排序算法供大家学习。 简介排序算法是用来根据元素对应的比较运算符重新排列给定的数组的算法，输出的数组是一个根据比较符从小到大或者从大到小依次排列的数组。比较运算符是用于确定相应数"><meta name="keywords" content="Leetcode"><meta name="author" content="SkironYong"><meta name="copyright" content="SkironYong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="十二种排序总结(快排、归并、希尔、计数排序等)"><meta name="twitter:description" content="前言排序算法在计算机科学入门课程中很普遍，在学习排序算法的时候，涉及到大量的各种核心算法概念，例如大O表示法，分治法，堆和二叉树之类的数据结构，随机算法，最佳、最差和平均情况分析，时空权衡以及上限和下限，本文就介绍了十二种排序算法供大家学习。 简介排序算法是用来根据元素对应的比较运算符重新排列给定的数组的算法，输出的数组是一个根据比较符从小到大或者从大到小依次排列的数组。比较运算符是用于确定相应数"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142635.gif"><meta property="og:type" content="article"><meta property="og:title" content="十二种排序总结(快排、归并、希尔、计数排序等)"><meta property="og:url" content="https://skironyong.github.io/SkironYong.github.io/posts/fdbc79f7.html"><meta property="og:site_name" content="SkironYong"><meta property="og:description" content="前言排序算法在计算机科学入门课程中很普遍，在学习排序算法的时候，涉及到大量的各种核心算法概念，例如大O表示法，分治法，堆和二叉树之类的数据结构，随机算法，最佳、最差和平均情况分析，时空权衡以及上限和下限，本文就介绍了十二种排序算法供大家学习。 简介排序算法是用来根据元素对应的比较运算符重新排列给定的数组的算法，输出的数组是一个根据比较符从小到大或者从大到小依次排列的数组。比较运算符是用于确定相应数"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142635.gif"><meta property="article:published_time" content="2020-04-11T09:42:39.000Z"><meta property="article:modified_time" content="2020-04-13T15:13:15.232Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://skironyong.github.io/SkironYong.github.io/posts/fdbc79f7.html"><link rel="prev" title="记第一次面试的凉经" href="https://skironyong.github.io/SkironYong.github.io/posts/9c11dd7b.html"><link rel="next" title="Leetcode 365水壶问题" href="https://skironyong.github.io/SkironYong.github.io/posts/82bc5cec.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"本人,超帥","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 图书</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 图库</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特性"><span class="toc-number">3.</span> <span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#稳定性"><span class="toc-number">3.0.1.</span> <span class="toc-text">稳定性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#比较排序、非比较排序"><span class="toc-number">3.0.2.</span> <span class="toc-text">比较排序、非比较排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十二种排序算法"><span class="toc-number">4.</span> <span class="toc-text">十二种排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-number">4.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择排序"><span class="toc-number">4.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入排序"><span class="toc-number">4.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#希尔排序"><span class="toc-number">4.4.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#归并排序"><span class="toc-number">4.5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速排序"><span class="toc-number">4.6.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆排序"><span class="toc-number">4.7.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉搜索树排序"><span class="toc-number">4.8.</span> <span class="toc-text">二叉搜索树排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计数排序"><span class="toc-number">4.9.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#桶排序"><span class="toc-number">4.10.</span> <span class="toc-text">桶排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基数排序"><span class="toc-number">4.11.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TimSort"><span class="toc-number">4.12.</span> <span class="toc-text">TimSort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">4.13.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转载"><span class="toc-number">4.14.</span> <span class="toc-text">转载</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142635.gif)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">SkironYong</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 图书</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 图库</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">十二种排序总结(快排、归并、希尔、计数排序等)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-11 17:42:39"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-13 23:13:15"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-13</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">6.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 22 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/posts/fdbc79f7.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/posts/fdbc79f7.html" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>排序算法在计算机科学入门课程中很普遍，在学习排序算法的时候，涉及到大量的各种核心算法概念，例如大O表示法，分治法，堆和二叉树之类的数据结构，随机算法，最佳、最差和平均情况分析，时空权衡以及上限和下限，本文就介绍了十二种排序算法供大家学习。</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>排序算法是用来根据元素对应的比较运算符重新排列给定的数组的算法，输出的数组是一个根据比较符从小到大或者从大到小依次排列的数组。比较运算符是用于确定相应数据结构中元素的新顺序，比如在整数数组里面，对应的比较符号就是大于或者小于号，用户也可以自己定义对应的比较运算符。</p>
<p>比如如果输入是[4,2,3,1]，按照从小到大输出，结果应该是<code>[1,2,3,4]</code></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><p>如果在数组中有两个元素是相等的，在经过某个排序算法之后，原来在前面的的那个元素仍然在另一个元素的前面，那么我们就说这个排序算法是稳定的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331135617.jpg" alt="stable sort"></p>
<p>如果在排序之后，原来的两个相等元素中在前面的一个元素被移到了后面，那么这个算法就是不稳定的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331135648.jpg" alt="unstable sort"></p>
<p>比如排序之前数组为<code>[3(a),2,3(b)]</code>（其中<code>a</code>和<code>b</code>分别代表两个不同的<code>3</code>），经过某个排序算法之后是<code>[2,3(a),3(b)]</code>，那么这个算法就是稳定的；如果变成了<code>[2,3(b),3(a)]</code>，那么这个算法是不稳定的。</p>
<p>再比如在按照身高排队去食堂打饭的过程中，小明和小刚的身高都是170，原来小明在小刚前面，但是经过排序之后小明发现小刚到了他前面了，这样小明肯定对这个不稳定的排序有意见。</p>
<h5 id="比较排序、非比较排序"><a href="#比较排序、非比较排序" class="headerlink" title="比较排序、非比较排序"></a>比较排序、非比较排序</h5><p>如果一个算法需要在排序的过程中使用比较操作来判断两个元素的大小关系，那么这个排序算法就是<strong>比较排序</strong>，大部分排序算法都是比较排序，比如冒泡排序、插入排序、堆排序等等，这种排序算法的平均时间复杂度最快也只能是O(nlogn)。</p>
<p><strong>非比较排序</strong>比较典型的有计数排序、桶排序和基数排序，这类排序能够脱离比较排序时间复杂度的束缚，达到O(n)级别的效率。</p>
<h3 id="十二种排序算法"><a href="#十二种排序算法" class="headerlink" title="十二种排序算法"></a>十二种排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序是从左到右依次比较相邻的两个元素，如果前一个元素比较大，就把前一个元素和后一个交换位置，遍历数组之后保证最后一个元素相对于前面的永远是最大的。然后让最后一个保持不变，重新遍历前<code>n-1</code>个元素，保证第<code>n-1</code>个元素在前<code>n-1</code>个元素里面是最大的。依此规律直到第<code>2</code>个元素是前<code>2</code>个元素里面最大的，排序就结束了。</p>
<p>因为这个排序的过程很像冒泡泡，找到最大的元素不停的移动到最后端，所以这个排序算法就叫冒泡排序。<br><img src="/SkironYong.github.io/posts/fdbc79f7.htm/E:%5CTypora%5CTypora%5CNotes%5CLeetCode%5C%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%5C%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%5C20200331140713.gif" alt><br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">// 冒泡得到n-1个最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j-<span class="number">1</span>]&gt;nums[j])</span><br><span class="line">                swap(nums, j, j-<span class="number">1</span>);           <span class="comment">// 交换得到较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序的最大特点就是代码简单，短短的五行代码就能完成整个排序的操作。</p>
<p>时间复杂度比较稳定不管怎样都需要O(n^2^)次比较，所以是O(n^2^)的时间复杂度。</p>
<p>空间复杂度是O(1)，所有操作在原来的数组完成就可以了，不需要额外的空间。</p>
<p>算法是稳定的，在冒泡的过程中如果两个元素相等，那么他们的位置是不会交换的。</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序的思路比较简单，先找到前<code>n</code>个元素中最大的值，然后和最后一个元素交换，这样保证最后一个元素一定是最大的，然后找到前<code>n-1</code>个元素中的最大值，和第<code>n-1</code>个元素进行交换，然后找到前<code>n-2</code>个元素中最大值，和第<code>n-2</code>个元素交换，依次类推到第2个元素，这样就得到了最后的排序数组。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331141200.gif" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;         <span class="comment">// 最大元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[maxIndex]&lt;nums[j]) &#123;</span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, maxIndex, i);   <span class="comment">// 把这个最大的元素移到最后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和冒泡排序一样比较稳定，都需要O(n^2^)次比较，所以时间复杂度是O(n^2^)</p>
<p>空间复杂度是O(1)，不需要额外空间，是原地算法。</p>
<p>选择排序最简单的版本是不稳定的，比如数组<code>[1,3,2,2]</code>，表示为<code>[1,3,2(a),2(b)]</code>，在经过一轮遍历之后变成了<code>[1,2(b),2(a),3]</code>，两个<code>2</code>之间的顺序因为第一个<code>2</code>和<code>3</code>的调换而颠倒了，所以不是稳定排序。</p>
<p>不过可以改进一下选择排序变成稳定的。原来不稳定是因为交换位置导致的，现在如果改成<strong>插入操作</strong>（不是使用数组而是链表，把最大的元素插入到最后）的话，就能变成稳定排序。比如<code>[1,3,2(a),2(b)]</code>，在第一轮中变成了<code>[1,2(a),2(b),3]</code>，这样就能够保持相对位置，变成稳定排序。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序的核心思想是遍历整个数组，保持当前元素左侧始终是排序后的数组，然后将当前元素插入到前面排序完成的数组的对应的位置，使其保持排序状态。有点动态规划的感觉，类似于先把前<code>i-1</code>个元素排序完成，再插入第<code>i</code>个元素，构成<code>i</code>个元素的有序数组。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331141550.gif" alt="insertion sort"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;   <span class="comment">// 从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;nums[j]&lt;nums[j-<span class="number">1</span>]) &#123;     <span class="comment">// 将当前元素移动到合适的位置</span></span><br><span class="line">            swap(nums, j, j-<span class="number">1</span>);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度上，插入排序在最好的情况，也就是数组已经排好序的时候，复杂度是O(n)，在其他情况下都是O(n2)。</p>
<p>空间复杂度是O(1)，不需要额外的空间，是原地算法。</p>
<p>插入排序是稳定排序，每次交换都是相邻元素的交换，不会有选择排序的那种跳跃式交换元素。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序可以看作是一个冒泡排序或者插入排序的变形。希尔排序在每次的排序的时候都把数组拆分成若干个序列，一个序列的相邻的元素索引相隔的固定的距离<code>gap</code>，每一轮对这些序列进行冒泡或者插入排序，然后再缩小<code>gap</code>得到新的序列一一排序，直到<code>gap</code>为0</p>
<p>比如对于数组<code>[5,2,4,3,1,2]</code>，第一轮<code>gap=3</code>拆分成<code>[5,3]</code>、<code>[2,1]</code>和<code>[4,2]</code>三个数组进行插入排序得到<code>[3,1,2,5,2,4]</code>；第二轮<code>gap=1</code>，拆分成<code>[3,2,2]</code>和<code>[1,5,4]</code>进行插入排序得到<code>[2,1,2,4,3,5]</code>；最后<code>gap=0</code>，全局插入排序得到<code>[1,2,2,3,4,5]</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142016.gif" alt="shell sort"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shellSor2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = nums.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gap; i++) &#123;                        <span class="comment">// 对每个子序列进行排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+gap; j &lt; nums.length; j+=gap) &#123;     <span class="comment">// 插入排序的部分</span></span><br><span class="line">                <span class="keyword">int</span> temp = j;</span><br><span class="line">                <span class="keyword">while</span> (temp &gt; i &amp;&amp; nums[temp] &lt; nums[temp-gap]) &#123;</span><br><span class="line">                    swap(nums, temp, temp-gap);</span><br><span class="line">                    temp -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Donald Shell于1959年发布了这种排序算法，运行时间在很大程度上取决于它使用的间隔，在实际使用中，其时间复杂度仍然是一个悬而未决的问题，基本在O(n^2^)和O(n^4/3^)之间。</p>
<p>空间复杂度是O(1)，是原地算法。</p>
<p>这个算法是不稳定的，里面有很多不相邻元素的交换操作。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序是典型的使用<strong>分治思想</strong>（divide-and-conquer）解决问题的案例。在排序的过程中，把原来的数组变成左右两个数组，然后分别进行排序，当左右的子数组排序完毕之后，再合并这两个子数组形成一个新的排序数组。整个过程递归进行，当只剩下一个元素或者没有元素的时候就直接返回。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142138.gif" alt="merge sort"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;  <span class="comment">// 需要左右边界确定排序范围</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    mergeSort(nums, left, mid);                           <span class="comment">// 先对左右子数组进行排序</span></span><br><span class="line">    mergeSort(nums, mid+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];                   <span class="comment">// 临时数组存放合并结果</span></span><br><span class="line">    <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=right) &#123;                            <span class="comment">// 开始合并数组</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;=nums[j]) temp[cur] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[cur] = nums[j++];</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid) temp[cur++] = nums[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=right) temp[cur++] = nums[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k++) &#123;             <span class="comment">// 合并数组完成，拷贝到原来的数组中</span></span><br><span class="line">        nums[left+k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度上归并排序能够稳定在O(nlogn)的水平，在每一级的合并排序数组过程中总的操作次数是n，总的层级数是logn，相乘得到最后的结果就是O(nlogn)</p>
<p>空间复杂度是O(n)，因为在合并的过程中需要使用临时数组来存放临时排序结果。</p>
<p>归并排序是稳定排序，保证原来相同的元素能够保持相对的位置。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>其核心的思路是取第一个元素（或者最后一个元素）作为分界点，把整个数组分成左右两侧，左边的元素小于或者等于分界点元素，而右边的元素大于分界点元素，然后把分界点移到中间位置，对左右子数组分别进行递归，最后就能得到一个排序完成的数组。当子数组只有一个或者没有元素的时候就结束这个递归过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142635.gif" alt="quick sort"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = left+<span class="number">1</span>;               <span class="comment">// 小于分界点元素的最右侧的指针</span></span><br><span class="line">    <span class="keyword">int</span> hi = right;                <span class="comment">// 大于分界点元素的最左侧的指针</span></span><br><span class="line">    <span class="keyword">while</span> (lo&lt;=hi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[lo]&gt;nums[left]) &#123; <span class="comment">// 交换元素确保左侧指针指向元素小于分界点元素</span></span><br><span class="line">            swap(nums, lo, hi);</span><br><span class="line">            hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lo--;                          <span class="comment">// 回到小于分界点元素数组的最右侧</span></span><br><span class="line">    swap(nums, left, lo);          <span class="comment">// 将分界点元素移到左侧数组最右侧</span></span><br><span class="line">    quickSort2(nums, left, lo-<span class="number">1</span>);</span><br><span class="line">    quickSort2(nums, lo+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我自己还有另一种快排写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> [] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> pivot=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">         pivot=partition(arr,left,right);</span><br><span class="line">         quickSort(arr,left,pivot-<span class="number">1</span>);</span><br><span class="line">         quickSort(arr,pivot+<span class="number">1</span>,right);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> key=arr[left];</span><br><span class="line">      <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">         <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;=key) &#123;</span><br><span class="line">            right--;</span><br><span class="line">         &#125;</span><br><span class="line">         arr[left]=arr[right];</span><br><span class="line">         <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;=key) &#123;</span><br><span class="line">            left++;</span><br><span class="line">         &#125;</span><br><span class="line">         arr[right]=arr[left];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[left]=key;</span><br><span class="line">      <span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>

<p>时间复杂度在最佳情况是O(nlogn)，但是如果分界点元素选择不当可能会恶化到O(n^2^)，但是这种情况比较少见（比如数组完全逆序），如果随机选择分界点的话，时间复杂度能够稳定在O(nlogn)。另外如果元素中相同元素数量比较多的话，也会降低排序性能。</p>
<p>空间复杂度在O(logn)水平，属于堆栈调用，在最坏的情况下空间复杂度还是O(n)，平均情况下复杂度是O(logn)</p>
<p>快速排序是不稳定的，因为包含跳跃式交换元素位置。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是一个效率要高得多的选择排序，首先把整个数组变成一个最大堆，然后每次从堆顶取出最大的元素，这样依次取出的最大元素就形成了一个排序的数组。堆排序的核心分成两个部分，第一个是新建一个堆，第二个是弹出堆顶元素后重建堆。</p>
<p>新建堆不需要额外的空间，而是使用原来的数组，一个数组在另一个维度上可以当作一个完全二叉树（除了最后一层之外其他的每一层都被完全填充，并且所有的节点都向左对齐），对于下标为<code>i</code>的元素，他的子节点是<code>2*i+1</code>和<code>2*i+2</code>（前提是没有超出边界）。在新建堆的时候从左向右开始遍历，当遍历到一个元素的时候，重新排列从这个元素节点到根节点的所有元素，保证满足最大堆的要求（父节点比子节点要大）。遍历完整个数组的时候，这个最大堆就完成了。</p>
<p>在弹出根节点之后（把根节点的元素和树的最底层最右侧的元素互换），堆被破坏，需要重建。从根节点开始和两个子节点比较，如果父节点比最大的子节点小，那么就互换父节点和最大的子节点，然后把互换后在子节点位置的父节点当作新的父节点，和它的子节点比较，如此往复直到最后一层，这样最大堆就重建完毕了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331143454.gif" alt="heap sort"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    heapify(nums);                                 <span class="comment">// 新建一个最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, i);                       <span class="comment">// 弹出最大堆的堆顶放在最后</span></span><br><span class="line">        rebuildHeap(nums, <span class="number">0</span>,i-<span class="number">1</span>);          <span class="comment">// 重建最大堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> par = (i-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;                       <span class="comment">// 找到父节点</span></span><br><span class="line">        <span class="keyword">int</span> child = i;                            <span class="comment">// 定义子节点</span></span><br><span class="line">        <span class="keyword">while</span> (child&gt;<span class="number">0</span>&amp;&amp;nums[par]&lt;nums[child]) &#123;  <span class="comment">// 从子节点到根节点构建最大堆</span></span><br><span class="line">            swap(nums, par, child);</span><br><span class="line">            child = par;</span><br><span class="line">            par = (par-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebuildHeap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> par, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span>*par+<span class="number">1</span>;                           <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span>*par+<span class="number">2</span>;                          <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right&lt;=last &amp;&amp; nums[right]&gt;nums[left]) &#123;  <span class="comment">// 找到最大子节点</span></span><br><span class="line">        maxIndex = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left&lt;=last &amp;&amp; nums[par] &lt; nums[maxIndex]) &#123;<span class="comment">// 和最大子节点比较</span></span><br><span class="line">        swap(nums, par, maxIndex);                 <span class="comment">// 互换到最大子节点</span></span><br><span class="line">        rebuildHeap(nums, maxIndex, last);         <span class="comment">// 重建最大子节点代表的子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度稳定在O(nlogn)，因为在构建堆的时候时间遍历数组对于每个元素需要进行O(logn)次比较，时间复杂度是O(nlogn)。在弹出每个元素重建堆需要O(logn)的复杂度，时间复杂度也是O(nlogn)，所以整体的时间复杂度是O(nlogn)</p>
<p>空间复杂度是O(1)，在原数组进行所有操作就可以了。</p>
<p>堆排序是不稳定，堆得构建和重建的过程都会打乱元素的相对位置。</p>
<h4 id="二叉搜索树排序"><a href="#二叉搜索树排序" class="headerlink" title="二叉搜索树排序"></a>二叉搜索树排序</h4><p>二叉树搜索排序用数组内的所有元素构建一个搜索二叉树，然后用中序遍历重新将所有的元素填充回原来的数组中。因为搜索二叉树不能用数组来表示，所以必须使用额外的数据结构来构建二叉树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331144034.gif" alt="binary search tree sort"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] bstSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[<span class="number">0</span>]);   <span class="comment">// 构建根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;  <span class="comment">// 将所有的元素插入到二叉搜索树中</span></span><br><span class="line">        buildTree(root, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    inorderTraversal(root, nums, <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>]);<span class="comment">// 中序遍历获取二叉树中的所有节点</span></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode node, <span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorderTraversal(node.left, nums, pos);</span><br><span class="line">    nums[pos[<span class="number">0</span>]++] = node.val;</span><br><span class="line">    inorderTraversal(node.right, nums, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(TreeNode node, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= node.val) &#123;                   <span class="comment">// 插入到右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buildTree(node.right, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                 <span class="comment">// 插入到左子树中</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buildTree(node.left, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;   <span class="comment">// 树节点的数据结构</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度上面根据原数组变化比较大，最差情况是整个数组是已经排好序的，这样二叉树会变成一个链表结构，时间复杂度退化到了O(n^2^)，但是最优和平均情况下时间复杂度在O(nlogn)水平。</p>
<p>空间复杂度是O(n)，因为要构建一个包含<code>n</code>个元素的二叉搜索树。</p>
<p>这个算法是稳定，在构建二叉树的过程中能够保证元素顺序的一致性。</p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序是一个最基本的非比较排序，能够将时间复杂度提高到O(n)的水平，但是使用上比较有局限性，通常只能应用在键的变化范围比较小的情况下，如果键的变化范围特别大，建议使用基数排序。</p>
<p>计数排序的过程是创建一个长度为数组中最小和最大元素之差的数组，分别对应数组中的每个元素，然后用这个新的数组来统计每个元素出现的频率，然后遍历新的数组，根据每个元素出现的频率把元素放回到老的数组中，得到已经排好序的数组。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331144204.gif" alt="count sort"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;            <span class="comment">// 找到最大最小值</span></span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>]; <span class="comment">// 建立新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;            <span class="comment">// 统计每个元素出现频率</span></span><br><span class="line">        count[num-min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;  <span class="comment">// 根据出现频率把计数数组中的元素放回到旧数组中</span></span><br><span class="line">        <span class="keyword">while</span> (count[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            nums[cur++] = i+min;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计数排序能够将时间复杂度降低到O(n+r)（r为数组元素变化范围），不过这是对于数组元素的变化范围不是特别大。随着范围的变大，计数排序的性能就会逐渐降低。</p>
<p>空间复杂度为O(n+r)，随着数组元素变化范围的增大，空间复杂度也会变大。</p>
<p>计数排序是稳定的，原来排在前面的相同在计数的时候，仍然是排在每个计数位置的前面，在最后复原的时候也是从每个计数位的前面开始复原，所以最后相对位置还是相同的。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>桶排序是将所有的元素分布到一系列的区间（也可以称之为<strong>桶</strong>）里面，然后对每个桶里面的所有元素分别进行排序的算法。</p>
<p>首先新建一个桶的数组，每个桶的规则需要提前制定好，比如元素在0~9为一个桶、10-19为一个桶。然后遍历整个待排序的数组，把元素分配到对应的桶里面。接下来单独对每个桶里面的元素进行排序，排序算法可以选择比较排序或者非比较排序，得到排序后的数组。最后把所有的桶内的元素还原到原数组里面得到最后的排序数组。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331144349.gif" alt="bucket sort"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> INTERVAL = <span class="number">100</span>;               <span class="comment">// 定义桶的大小</span></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;            <span class="comment">// 找到数组元素的范围</span></span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = (max - min + <span class="number">1</span>);      <span class="comment">// 计算出桶的数量</span></span><br><span class="line">    <span class="keyword">int</span> bucketSize = (count % INTERVAL == <span class="number">0</span>) ?( count / INTERVAL) : (count / INTERVAL+<span class="number">1</span>);</span><br><span class="line">    List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> List[bucketSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;            <span class="comment">// 把所有元素放入对应的桶里面</span></span><br><span class="line">        <span class="keyword">int</span> quotient = (num-min) / INTERVAL;</span><br><span class="line">        <span class="keyword">if</span> (buckets[quotient] == <span class="keyword">null</span>) buckets[quotient] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        buckets[quotient].add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bucket.sort(<span class="keyword">null</span>);       <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">            <span class="keyword">for</span> (Integer integer : bucket) &#123;  <span class="comment">// 还原桶里面的元素到原数组</span></span><br><span class="line">                nums[cur++] = integer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n+r)，空间复杂度O（n+r）稳定</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>假设当前数组的所有元素都是正数，桶的数量就固定在了10个，然后计算出最大元素的位数。首先根据每个元素的最低位进行分组，比如<code>1</code>就放入<code>1</code>这个桶，<code>13</code>就放入<code>3</code>这个桶，<code>111</code>也放入<code>1</code>这个桶，然后把所有的数字根据桶的顺序取出来，依次还原到原数组里面。在第二轮从第二位开始分组，比如<code>1</code>（看作<code>01</code>）放入<code>0</code>这个桶，<code>13</code>放入<code>1</code>这个桶，<code>111</code>也放入<code>1</code>这个桶，再把所有的元素从桶里面依次取出放入原数组。经过最大元素位数次的这样的操作之后，还原得到的数组就是一个已经排好序的数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331144658.gif" alt="radix sort"></p>
<p>考虑到数组里面还有负数的情况，可以把桶的大小扩大到19个，分别代表对应位在-9~9之间的数字，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;         <span class="comment">// 计算最大最小值</span></span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, -min);     <span class="comment">// 求得绝对值最大的值</span></span><br><span class="line">    <span class="keyword">int</span> digits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;              <span class="comment">// 计算绝对值最大的值的位数</span></span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        digits++;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> List[<span class="number">19</span>]; <span class="comment">// 建一个包含所有位数的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, mod = <span class="number">1</span>; i &lt; digits; i++, mod*=<span class="number">10</span>) &#123; <span class="comment">// 对十进制每一位进行基数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;                 <span class="comment">// 扫描数组将值放入对应的桶</span></span><br><span class="line">            pos = (num / mod) % <span class="number">10</span>;</span><br><span class="line">            buckets[pos+<span class="number">9</span>].add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123; <span class="comment">// 将桶内元素放回到数组里面</span></span><br><span class="line">            <span class="keyword">if</span> (bucket!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : bucket) &#123;</span><br><span class="line">                    nums[cur++] = integer;</span><br><span class="line">                &#125;</span><br><span class="line">                bucket.clear();                <span class="comment">// 将桶清空</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h4><p>Timsort是由Tim Peters在2002年实现的，自Python 2.3以来，它一直是Python的标准排序算法。Java在JDK中使用Timsort对非基本类型进行排序。Android平台和GNU Octave还将其用作默认排序算法。</p>
<p>Timsort是一种稳定的混合排序算法，同时应用了二分插入排序和归并排序的思想，在时间上击败了其他所有排序算法。它在最坏情况下的时间复杂度为O(nlogn)优于快速排序；最佳情况的时间复杂度为O(n)，优于归并排序和堆排序。</p>
<p>由于使用了归并排序，使用额外的空间保存数据，TimSort空间复杂度是O(n)</p>
<p><strong>Collection.sort()</strong>用到的算法就是TimSort算法</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th align="center"><strong>排序算法</strong></th>
<th align="center"><strong>最好情况</strong></th>
<th align="center"><strong>平均情况</strong></th>
<th align="center"><strong>最差情况</strong></th>
<th align="center"><strong>空间复杂度</strong></th>
<th align="center"><strong>稳定性</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">n^2^</td>
<td align="center">n^2^</td>
<td align="center">n^2^</td>
<td align="center">1</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">n^2^</td>
<td align="center">n^2^</td>
<td align="center">n^2^</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">n</td>
<td align="center">n^2^</td>
<td align="center">n^2^</td>
<td align="center">1</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">nlogn</td>
<td align="center">nlogn</td>
<td align="center">n^4/3^</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">二叉树排序</td>
<td align="center">nlogn</td>
<td align="center">nlogn</td>
<td align="center">n^2^</td>
<td align="center">n</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">nlogn</td>
<td align="center">nlogn</td>
<td align="center">nlogn</td>
<td align="center">n</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">nlogn</td>
<td align="center">nlogn</td>
<td align="center">n^2^</td>
<td align="center">logn</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">nlogn</td>
<td align="center">nlogn</td>
<td align="center">nlogn</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">-</td>
<td align="center">n+r</td>
<td align="center">n+r</td>
<td align="center">n+r</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">-</td>
<td align="center">n+r</td>
<td align="center">n+r</td>
<td align="center">n+r</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">-</td>
<td align="center">nk/d</td>
<td align="center">nk/d</td>
<td align="center">n+2^d^</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">TimSort</td>
<td align="center">n</td>
<td align="center">nlogn</td>
<td align="center">nlogn</td>
<td align="center">n</td>
<td align="center">✓</td>
</tr>
</tbody></table>
<p>备注：r为排序数字的范围，d是数字总位数，k是数字总个数</p>
<h4 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h4><blockquote>
<p>作者：悟Space</p>
<p>转载链接：<a href="http://sunshuyi.vip/2020/03/15/leetcode/leetcode-sort/" target="_blank" rel="noopener">http://sunshuyi.vip/2020/03/15/leetcode/leetcode-sort/</a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SkironYong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://skironyong.github.io/SkironYong.github.io/posts/fdbc79f7.html">https://skironyong.github.io/SkironYong.github.io/posts/fdbc79f7.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://skironyong.github.io/SkironYong.github.io" target="_blank">SkironYong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200612095431.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/posts/9c11dd7b.html"><img class="prev_cover" src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200412204620.jpg" onerror="onerror=null;src='undefined'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">记第一次面试的凉经</div></div></a></div><div class="next-post pull_right"><a href="/posts/82bc5cec.html"><img class="next_cover" src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200406191937.jpg" onerror="onerror=null;src='undefined'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Leetcode 365水壶问题</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/82bc5cec.html" title="Leetcode 365水壶问题"><img class="relatedPosts_cover "src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200406191937.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-21</div><div class="relatedPosts_title">Leetcode 365水壶问题</div></div></a></div><div class="relatedPosts_item"><a href="/posts/88d5f208.html" title="Leetcode40经典排序算法解决topK问题"><img class="relatedPosts_cover "src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200406193249.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-20</div><div class="relatedPosts_title">Leetcode40经典排序算法解决topK问题</div></div></a></div><div class="relatedPosts_item"><a href="/posts/64609a71.html" title="Leetcode 1160拼写单词"><img class="relatedPosts_cover "src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/leetcode1140.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-20</div><div class="relatedPosts_title">Leetcode 1160拼写单词</div></div></a></div><div class="relatedPosts_item"><a href="/posts/8743da55.html" title="Leetcode 300最长上升子序列"><img class="relatedPosts_cover "src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200406203800.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-20</div><div class="relatedPosts_title">Leetcode 300最长上升子序列</div></div></a></div><div class="relatedPosts_item"><a href="/posts/ef60d55f.html" title="Leetcode17 电话号码组合"><img class="relatedPosts_cover "src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200406201053.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-29</div><div class="relatedPosts_title">Leetcode17 电话号码组合</div></div></a></div><div class="relatedPosts_item"><a href="/posts/ce637d7c.html" title="Leetcode22括号生成"><img class="relatedPosts_cover "src="https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200406201053.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-29</div><div class="relatedPosts_title">Leetcode22括号生成</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  appId: 'IRUfN9iVHLBGKtLYCkfHP4Iz-gzGzoHsz',
  appKey: '1XObAXtfulNqntVKck7dqWdc',
  placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  mathjax: false
});</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/SkironYong/skironImgs/img/20200331142635.gif)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By SkironYong</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Welcome to my <a href="http://skiron.xyz/" target="_blank" rel="noopener">blog</a>!</div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>陕ICP备20009508号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>